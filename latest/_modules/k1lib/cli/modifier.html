<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>k1lib.cli.modifier &mdash; k1lib  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> k1lib
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../base.html">Base module</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../cli/index.html">k1lib.cli module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../callbacks/index.html">k1lib.callbacks module</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../k1a.html">k1lib._k1a module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../k1ui.html">k1lib.k1ui module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../eqn.html">k1lib.eqn module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fmt.html">k1lib.fmt module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graphEqn.html">k1lib.graphEqn module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../imports.html">k1lib.imports module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mo.html">k1lib.mo module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../knn.html">k1lib.knn module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../p5.html">k1lib.p5 module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../schedule.html">k1lib.schedule module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../selector.html">k1lib.selector module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../selen.html">k1lib.selen module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../serve.html">k1lib.serve module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../viz.html">k1lib.viz module</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../monkey.html">Monkey patched classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelogs.html">Changelogs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">k1lib</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">k1lib.cli.modifier</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for k1lib.cli.modifier</h1><div class="highlight"><pre>
<span></span><span class="c1"># AUTOGENERATED FILE! PLEASE DON&#39;T EDIT HERE. EDIT THE SOURCE NOTEBOOKS INSTEAD</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is for quick modifiers, think of them as changing formats</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;applyS&quot;</span><span class="p">,</span> <span class="s2">&quot;aS&quot;</span><span class="p">,</span> <span class="s2">&quot;apply&quot;</span><span class="p">,</span> <span class="s2">&quot;map_&quot;</span><span class="p">,</span> <span class="s2">&quot;applyMp&quot;</span><span class="p">,</span> <span class="s2">&quot;parallel&quot;</span><span class="p">,</span> <span class="s2">&quot;applyCl&quot;</span><span class="p">,</span>
           <span class="s2">&quot;applyTh&quot;</span><span class="p">,</span> <span class="s2">&quot;applySerial&quot;</span><span class="p">,</span>
           <span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="s2">&quot;sortF&quot;</span><span class="p">,</span> <span class="s2">&quot;consume&quot;</span><span class="p">,</span> <span class="s2">&quot;randomize&quot;</span><span class="p">,</span> <span class="s2">&quot;stagger&quot;</span><span class="p">,</span> <span class="s2">&quot;op&quot;</span><span class="p">,</span>
           <span class="s2">&quot;integrate&quot;</span><span class="p">,</span> <span class="s2">&quot;roll&quot;</span><span class="p">]</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">k1lib.cli.init</span> <span class="kn">import</span> <span class="n">patchDefaultDelim</span><span class="p">,</span> <span class="n">BaseCli</span><span class="p">,</span> <span class="n">fastF</span>
<span class="kn">import</span> <span class="nn">k1lib.cli</span> <span class="k">as</span> <span class="nn">cli</span><span class="o">,</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span><span class="o">,</span> <span class="nn">threading</span><span class="o">,</span> <span class="nn">gc</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">k1lib</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">update_wrapper</span><span class="p">,</span> <span class="n">lru_cache</span>
<span class="kn">from</span> <span class="nn">k1lib.cli.typehint</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">dill</span><span class="o">,</span> <span class="nn">pickle</span><span class="o">,</span> <span class="nn">k1lib</span><span class="o">,</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">atexit</span><span class="o">,</span> <span class="nn">signal</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">sys</span>
<span class="k">try</span><span class="p">:</span> <span class="kn">import</span> <span class="nn">torch</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">torch.multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span><span class="p">;</span> <span class="n">hasTorch</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span><span class="p">:</span> <span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span><span class="p">;</span> <span class="n">hasTorch</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">try</span><span class="p">:</span> <span class="kn">import</span> <span class="nn">ray</span><span class="p">;</span> <span class="n">hasRay</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span><span class="p">:</span> <span class="n">hasRay</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">settings</span> <span class="o">=</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">cli</span>
<div class="viewcode-block" id="applyS"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyS">[docs]</a><span class="k">class</span> <span class="nc">applyS</span><span class="p">(</span><span class="n">BaseCli</span><span class="p">):</span>                                                           <span class="c1"># applyS</span>
<div class="viewcode-block" id="applyS.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyS.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>                 <span class="c1"># applyS</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like :class:`apply`, but much simpler, just operating on the entire input</span>
<span class="sd">object, essentially. The &quot;S&quot; stands for &quot;single&quot;. There&#39;s</span>
<span class="sd">also an alias shorthand for this called :class:`aS`. Example::</span>

<span class="sd">    # returns 5</span>
<span class="sd">    3 | aS(lambda x: x+2)</span>

<span class="sd">Like :class:`apply`, you can also use this as a decorator like this::</span>

<span class="sd">    @aS</span>
<span class="sd">    def f(x):</span>
<span class="sd">        return x+2</span>
<span class="sd">    # returns 5</span>
<span class="sd">    3 | f</span>

<span class="sd">This also decorates the returned object so that it has same qualname, docstring</span>
<span class="sd">and whatnot.</span>

<span class="sd">.. admonition:: Shorthands</span>

<span class="sd">    Writing out &quot;lambda x:&quot; all the time is annoying, and there are ways</span>
<span class="sd">    to quickly say ``lambda x: x+2`` like so::</span>

<span class="sd">        3 | op()+2 # returns 5</span>
<span class="sd">        3 | aS(&quot;x+2&quot;) # returns 5. Behind the scenes, it compiles and execute `lambda x: x+2`</span>

<span class="sd">    The first way is to use :class:`op`, that will absorb all operations done on it,</span>
<span class="sd">    like &quot;+&quot;, and returns a function that essentially replays all the operations.</span>

<span class="sd">    In the second way, you only have to pass in the string containing code that you want</span>
<span class="sd">    done on the variable &quot;x&quot;. Then internally, it will compile to regular Python code.</span>

<span class="sd">    In fact, you can pass in ``op()`` or just a string to any cli that accepts any kind</span>
<span class="sd">    of function, like :class:`~k1lib.cli.filt.filt` or :class:`apply`::</span>

<span class="sd">        range(4) | apply(&quot;x-2&quot;) | deref()</span>
<span class="sd">        range(4) | apply(op()-2) | deref()</span>
<span class="sd">        range(4) | filt(&quot;x%2&quot;) | deref()</span>
<span class="sd">        range(4) | filt(op()%2) | deref()</span>

<span class="sd">:param f: the function to be executed</span>
<span class="sd">:param kwargs: other keyword arguments to pass to the function, together with ``args``&quot;&quot;&quot;</span> <span class="c1"># applyS</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fs</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">]);</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>         <span class="c1"># applyS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fC</span> <span class="o">=</span> <span class="n">fastF</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="n">update_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">updated</span><span class="o">=</span><span class="p">())</span>     <span class="c1"># applyS</span></div>
    <span class="k">def</span> <span class="nf">_typehint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>                                                    <span class="c1"># applyS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasHint</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hint</span>                                       <span class="c1"># applyS</span>
        <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">_typehint</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>                                        <span class="c1"># applyS</span>
        <span class="k">except</span><span class="p">:</span> <span class="k">return</span> <span class="n">tAny</span><span class="p">()</span>                                                    <span class="c1"># applyS</span>
<div class="viewcode-block" id="applyS.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyS.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">:</span><span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>                                            <span class="c1"># applyS</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fC</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>                           <span class="c1"># applyS</span></div>
<div class="viewcode-block" id="applyS.__invert__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyS.__invert__">[docs]</a>    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                                                        <span class="c1"># applyS</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Configures it so that it expand the arguments out.</span>
<span class="sd">Example::</span>

<span class="sd">    # returns 5</span>
<span class="sd">    [2, 3] | ~aS(lambda x, y: x + y)</span>

<span class="sd">    def f(x, y, a=4):</span>
<span class="sd">        return x*y + a</span>
<span class="sd">    # returns 10</span>
<span class="sd">    [2, 3] | ~aS(f)</span>
<span class="sd">    # returns 11</span>
<span class="sd">    [2, 3] | ~aS(f, a=5)&quot;&quot;&quot;</span>                                                      <span class="c1"># applyS</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">;</span> <span class="n">kw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">;</span> <span class="k">return</span> <span class="n">applyS</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">));</span> <span class="c1"># applyS</span></div></div>
<span class="n">aS</span> <span class="o">=</span> <span class="n">applyS</span>                                                                      <span class="c1"># applyS</span>
<span class="k">def</span> <span class="nf">_allOpt_gen</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ir</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span> <span class="c1"># a is a complex, deref-ed structure    # _allOpt_gen</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span>                                                            <span class="c1"># _allOpt_gen</span>
    <span class="n">ir</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>                                                            <span class="c1"># _allOpt_gen</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span> <span class="n">_allOpt_gen</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>                                          <span class="c1"># _allOpt_gen</span>
<span class="k">def</span> <span class="nf">_allOpt_genIr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;(derefed structure, flattened structure, ir, depth)&quot;</span><span class="p">:</span> <span class="c1"># a is a complex, not yet deref-ed structure # _allOpt_genIr</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">())</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">a</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">(</span><span class="n">n</span><span class="p">));</span> <span class="n">ir</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="ow">or</span> <span class="p">(</span><span class="n">a</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="c1"># _allOpt_genIr</span>
    <span class="n">_allOpt_gen</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">joinStreams</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">ir</span><span class="p">,</span> <span class="n">n</span>       <span class="c1"># _allOpt_genIr</span>
<span class="k">def</span> <span class="nf">_allOpt_recover</span><span class="p">(</span><span class="n">b</span><span class="p">:</span><span class="n">Iterator</span><span class="p">[</span><span class="s2">&quot;data_structure&quot;</span><span class="p">],</span> <span class="n">ir</span><span class="p">:</span><span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">n</span><span class="p">):</span> <span class="c1"># assumes b and ir are iterators # _allOpt_recover</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">l</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">ir</span><span class="p">)</span>                                                       <span class="c1"># _allOpt_recover</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>                                                           <span class="c1"># _allOpt_recover</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_allOpt_recover</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>                      <span class="c1"># _allOpt_recover</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">b</span><span class="p">));</span> <span class="c1">#print(&quot;  &quot;*(4-n) + f&quot;appended: {ans}&quot;);      # _allOpt_recover</span>
    <span class="k">return</span> <span class="n">ans</span>                                                                   <span class="c1"># _allOpt_recover</span>
<div class="viewcode-block" id="apply"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.apply">[docs]</a><span class="k">class</span> <span class="nc">apply</span><span class="p">(</span><span class="n">BaseCli</span><span class="p">):</span>                                                            <span class="c1"># apply</span>
<div class="viewcode-block" id="apply.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.apply.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span> <span class="n">column</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="c1"># apply</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies a function f to every element in the incoming list/iterator.</span>
<span class="sd">Example::</span>

<span class="sd">    # returns [0, 1, 4, 9, 16]</span>
<span class="sd">    range(5) | apply(lambda x: x**2) | deref()</span>
<span class="sd">    # returns [[3.0, 1.0, 1.0], [3.0, 1.0, 1.0]], running the function on the 0th column</span>
<span class="sd">    torch.ones(2, 3) | apply(lambda x: x+2, 0) | deref()</span>
<span class="sd">    # returns [[0, -1, 2, 3, -4], [2, -3, 4, 5, -6], [0, -1, 4, 9, -16]], running the function on the 1st (0-index btw) and 4th columns</span>
<span class="sd">    [[0, 1, 2, 3, 4], [2, 3, 4, 5, 6], [0, 1, 4, 9, 16]] | apply(lambda x: -x, [1, 4]) | deref()</span>

<span class="sd">You can also use this as a decorator, like this::</span>

<span class="sd">    @apply</span>
<span class="sd">    def f(x):</span>
<span class="sd">        return x**2</span>
<span class="sd">    # returns [0, 1, 4, 9, 16]</span>
<span class="sd">    range(5) | f | deref()</span>

<span class="sd">You can also add a cache, like this::</span>

<span class="sd">    def calc(i): time.sleep(0.5); return i**2</span>
<span class="sd">    # takes 2.5s</span>
<span class="sd">    range(5) | repeatFrom(2) | apply(calc, cache=10) | deref()</span>
<span class="sd">    # takes 5s</span>
<span class="sd">    range(5) | repeatFrom(2) | apply(calc) | deref()</span>

<span class="sd">You can add custom keyword arguments into the function::</span>

<span class="sd">    def f(x, y, z=3):</span>
<span class="sd">        return x + y + z</span>
<span class="sd">    # returns [15, 17, 19, 21, 23]</span>
<span class="sd">    [range(5), range(10, 15)] | transpose() | ~apply(f, z=5) | deref()</span>

<span class="sd">If &quot;apply&quot; is too hard to remember, this cli also has an alias :class:`map_`</span>
<span class="sd">that kinda mimics Python&#39;s ``map()``. Also slight reminder that you can&#39;t pass</span>
<span class="sd">in extra positional args like in :class:`aS`, just extra keyword arguments.</span>

<span class="sd">See also: :class:`aS`, :class:`~k1lib.cli.filt.filt`</span>

<span class="sd">:param column: if not None, then applies the function to that column or columns only</span>
<span class="sd">:param cache: if specified, then caches this much number of values</span>
<span class="sd">:param kwargs: extra keyword arguments to pass in the function&quot;&quot;&quot;</span>                <span class="c1"># apply</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fs</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">]);</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span> <span class="c1"># f is the original operator, _fC is # apply</span>
        <span class="k">if</span> <span class="n">column</span><span class="p">:</span> <span class="c1"># quick type checks                                           # apply</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Applying a function on a negative-indexed column (</span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2">) is not supported&quot;</span><span class="p">)</span> <span class="c1"># apply</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>                                          <span class="c1"># apply</span>
                <span class="k">if</span> <span class="n">column</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="n">ex</span>                                          <span class="c1"># apply</span>
            <span class="k">else</span><span class="p">:</span>                                                                <span class="c1"># apply</span>
                <span class="n">column</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>                                            <span class="c1"># apply</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">column</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]):</span> <span class="k">raise</span> <span class="n">ex</span>                   <span class="c1"># apply</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">column</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fC</span> <span class="o">=</span> <span class="n">fastF</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>            <span class="c1"># apply</span>
        <span class="k">if</span> <span class="n">cache</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fC</span> <span class="o">=</span> <span class="n">lru_cache</span><span class="p">(</span><span class="n">cache</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fC</span><span class="p">)</span>                      <span class="c1"># apply</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1"># cached value to say that this apply is just being used as a wrapper, nothing out of the ordinary, like custom columns, cache or custom kwargs # apply</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">:</span> <span class="c1"># just propagating information upward, to save runtime graph analysis time # apply</span>
            <span class="k">try</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagatedF</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">_propagatedF</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_applyDepth</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">_applyDepth</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># assuming f is another apply() # apply</span>
            <span class="k">except</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagatedF</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_applyDepth</span> <span class="o">=</span> <span class="mi">1</span>                  <span class="c1"># apply</span>
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagatedF</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_applyDepth</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># might have to rethink if this depth should be 1 or not # apply</span>
        <span class="c1"># optimization 1: BaseCli._all_array_opt(), aimed at accelerating array types # apply</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__arrayTypeF</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># None for not formulated yet, 0 for cannot formulate a faster operation, else the cached, accelerated function (that might not work) # apply</span>
        <span class="c1"># optimization 2: BaseCli._all_opt(), aimed at accelerating language models # apply</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__allOptF</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># None for not formulated yet, 0 for cannot formulate a faster operation, else the cached, accelerated function (that will guaranteed to work) # apply</span></div>
    <span class="nd">@property</span>                                                                    <span class="c1"># apply</span>
    <span class="k">def</span> <span class="nf">_arrayTypeF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># optimization 1: returns None or the function (that might not work) # apply</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__arrayTypeF</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>                                   <span class="c1"># apply</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__arrayTypeF</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>                                            <span class="c1"># apply</span>
            <span class="n">arrs</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">last</span> <span class="o">=</span> <span class="bp">self</span> <span class="c1"># figure out the depth                        # apply</span>
            <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">apply</span><span class="p">)</span> <span class="ow">and</span> <span class="n">last</span><span class="o">.</span><span class="n">normal</span><span class="p">:</span> <span class="n">arrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last</span><span class="p">);</span> <span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="n">f</span> <span class="c1"># apply</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrs</span><span class="p">)</span>                                                    <span class="c1"># apply</span>
            <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__arrayTypeF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">return</span> <span class="kc">None</span>                    <span class="c1"># apply</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">cli</span><span class="o">.</span><span class="n">serial</span><span class="p">):</span> <span class="c1"># breaks up the serial: (A | B.all(2)).all(3) -&gt; A.all(3) | B.all(5) # apply</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__arrayTypeF</span> <span class="o">=</span> <span class="n">cli</span><span class="o">.</span><span class="n">serial</span><span class="p">(</span><span class="o">*</span><span class="p">[(</span><span class="n">e</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">BaseCli</span><span class="p">)</span> <span class="k">else</span> <span class="n">aS</span><span class="p">(</span><span class="n">e</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">last</span><span class="o">.</span><span class="n">clis</span><span class="p">]);</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__arrayTypeF</span> <span class="c1"># apply</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># it | A.all(3) -&gt; A._all_array_opt(it, 3). This function might return NotImplemented, which means it can&#39;t figure out how to utilize the speed up # apply</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__arrayTypeF</span> <span class="o">=</span> <span class="n">aS</span><span class="p">(</span><span class="k">lambda</span> <span class="n">it</span><span class="p">:</span> <span class="n">last</span><span class="o">.</span><span class="n">_all_array_opt</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">depth</span><span class="p">));</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__arrayTypeF</span> <span class="c1"># apply</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__arrayTypeF</span>                                                 <span class="c1"># apply</span>
    <span class="nd">@property</span>                                                                    <span class="c1"># apply</span>
    <span class="k">def</span> <span class="nf">_allOptF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># optimization 2: returns None or the function (that has to work all the time!) # apply</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__allOptF</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>                                      <span class="c1"># apply</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagatedF</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_propagatedF</span><span class="p">,</span> <span class="s2">&quot;_all_opt&quot;</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">__allOptF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">return</span> <span class="kc">None</span> <span class="c1"># apply</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagatedF</span><span class="o">.</span><span class="n">_all_opt</span>                                           <span class="c1"># apply</span>
        <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">it</span><span class="p">):</span> <span class="c1"># has to regenerate the IR on each pass through. Slow (O(30*n) or so), but the function this is supposed to run (LLMs), are even slower, so this is fine for now # apply</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">af</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">_allOpt_genIr</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_applyDepth</span><span class="p">)</span> <span class="c1"># af = a flat     # apply</span>
            <span class="k">return</span> <span class="n">_allOpt_recover</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">af</span><span class="p">)),</span> <span class="nb">iter</span><span class="p">(</span><span class="n">ir</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>                     <span class="c1"># apply</span>
        <span class="k">return</span> <span class="n">inner</span>                                                             <span class="c1"># apply</span>
    <span class="k">def</span> <span class="nf">_typehint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>                                                    <span class="c1"># apply</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>                                                  <span class="c1"># apply</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">tListIterSet</span><span class="p">):</span>                                    <span class="c1"># apply</span>
                <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="n">tIter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">_typehint</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">child</span><span class="p">))</span>                   <span class="c1"># apply</span>
                <span class="k">except</span><span class="p">:</span> <span class="k">return</span> <span class="n">tIter</span><span class="p">(</span><span class="n">tAny</span><span class="p">())</span>                                     <span class="c1"># apply</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_typehint</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>                                            <span class="c1"># apply</span>
    <span class="k">def</span> <span class="nf">_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># ~apply() case handled automatically # apply</span>
<div class="viewcode-block" id="apply.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.apply.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">:</span><span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>                                         <span class="c1"># apply</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">;</span> <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fC</span><span class="p">;</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span>                      <span class="c1"># apply</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>                                                            <span class="c1"># apply</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">:</span>                                                      <span class="c1"># apply</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">arrayTypes</span><span class="p">):</span> <span class="c1"># optimization 1         # apply</span>
                    <span class="n">af</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrayTypeF</span>                                        <span class="c1"># apply</span>
                    <span class="k">if</span> <span class="n">af</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># there&#39;re lots of code here, but it doesn&#39;t impact perf cause it&#39;s done once for each array object # apply</span>
                        <span class="k">try</span><span class="p">:</span>                                                     <span class="c1"># apply</span>
                            <span class="n">ans</span> <span class="o">=</span> <span class="n">af</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>                                         <span class="c1"># apply</span>
                            <span class="k">if</span> <span class="n">ans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span> <span class="k">return</span> <span class="n">ans</span>             <span class="c1"># apply</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="k">pass</span>                              <span class="c1"># apply</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__arrayTypeF</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># tried to use the accelerated version, but failed, so won&#39;t ever try the accelerated version again # apply</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allOptF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allOptF</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="c1"># optimization 2, for LLMs # apply</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">it</span><span class="p">)</span>                            <span class="c1"># apply</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>                                                 <span class="c1"># apply</span>
            <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>                                                         <span class="c1"># apply</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span> <span class="n">row</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">);</span> <span class="n">row</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">);</span> <span class="k">yield</span> <span class="n">row</span> <span class="c1"># apply</span>
            <span class="k">return</span> <span class="n">gen</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="c1"># return ([(e if i != c else f(e, **kwargs)) for i, e in enumerate(row)] for row in it) # old version # apply</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># List[int]                                                        # apply</span>
            <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>                                                         <span class="c1"># apply</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>                                                   <span class="c1"># apply</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>                                              <span class="c1"># apply</span>
                    <span class="k">for</span> <span class="n">c_</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="n">c_</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">c_</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>                  <span class="c1"># apply</span>
                    <span class="k">yield</span> <span class="n">row</span>                                                    <span class="c1"># apply</span>
            <span class="k">return</span> <span class="n">gen</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>                                                       <span class="c1"># apply</span></div>
<div class="viewcode-block" id="apply.__invert__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.apply.__invert__">[docs]</a>    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                                                        <span class="c1"># apply</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Same mechanism as in :class:`applyS`, it expands the</span>
<span class="sd">arguments out. Just for convenience really. Example::</span>

<span class="sd">    # returns [10, 12, 14, 16, 18]</span>
<span class="sd">    [range(5), range(10, 15)] | transpose() | ~apply(lambda x, y: x+y) | deref()&quot;&quot;&quot;</span> <span class="c1"># apply</span>
        <span class="k">return</span> <span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span> <span class="c1"># apply</span></div></div>
<span class="n">map_</span> <span class="o">=</span> <span class="n">apply</span>                                                                     <span class="c1"># apply</span>
<span class="k">def</span> <span class="nf">executeFunc</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>                                                   <span class="c1"># executeFunc</span>
    <span class="kn">import</span> <span class="nn">dill</span><span class="o">,</span> <span class="nn">time</span><span class="p">;</span> <span class="n">f</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">dill</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">common</span><span class="p">)</span>                            <span class="c1"># executeFunc</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">dill</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>                                          <span class="c1"># executeFunc</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">);</span> <span class="k">return</span> <span class="n">res</span> <span class="c1"># suggestion by https://stackoverflow.com/questions/36359528/broken-pipe-error-with-multiprocessing-queue # executeFunc</span>
<span class="k">def</span> <span class="nf">terminateGraceful</span><span class="p">():</span> <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIG_IGN</span><span class="p">)</span>            <span class="c1"># terminateGraceful</span>
<span class="n">_k1_applyMp_global_ctx</span> <span class="o">=</span> <span class="p">{};</span> <span class="n">_k1_applyMp_global_ctx_autoInc</span> <span class="o">=</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">AutoIncrement</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;_k1_applyMp&quot;</span><span class="p">)</span> <span class="c1"># terminateGraceful</span>
<div class="viewcode-block" id="applyMp"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyMp">[docs]</a><span class="k">class</span> <span class="nc">applyMp</span><span class="p">(</span><span class="n">BaseCli</span><span class="p">):</span>                                                          <span class="c1"># applyMp</span>
    <span class="n">_pools</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>                                                               <span class="c1"># applyMp</span>
    <span class="n">_torchNumThreads</span> <span class="o">=</span> <span class="kc">None</span>                                                      <span class="c1"># applyMp</span>
<div class="viewcode-block" id="applyMp.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyMp.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span> <span class="n">prefetch</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">utilization</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">bs</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">newPoolEvery</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="c1"># applyMp</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like :class:`apply`, but execute a function over the input iterator</span>
<span class="sd">in multiple processes. Example::</span>

<span class="sd">    # returns [3, 2]</span>
<span class="sd">    [&quot;abc&quot;, &quot;de&quot;] | applyMp(len) | deref()</span>
<span class="sd">    # returns [5, 6, 9]</span>
<span class="sd">    range(3) | applyMp(lambda x, bias: x**2+bias, bias=5) | deref()</span>

<span class="sd">    # returns [[1, 2, 3], [1, 2, 3]], demonstrating outside vars work</span>
<span class="sd">    someList = [1, 2, 3]</span>
<span class="sd">    [&quot;abc&quot;, &quot;de&quot;] | applyMp(lambda s: someList) | deref()</span>

<span class="sd">Internally, this will continuously spawn new jobs up until 80% of all CPU</span>
<span class="sd">cores are utilized. On posix systems, the default multiprocessing start method is</span>
<span class="sd">``fork()``. This sort of means that all the variables in memory will be copied</span>
<span class="sd">over. On windows and macos, the default start method is ``spawn``, meaning each</span>
<span class="sd">child process is a completely new interpreter, so you have to pass in all required</span>
<span class="sd">variables and reimport every dependencies. Read more at https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods</span>

<span class="sd">If you don&#39;t wish to schedule all jobs at once, you can specify a ``prefetch``</span>
<span class="sd">amount, and it will only schedule that much jobs ahead of time. Example::</span>

<span class="sd">    range(10000) | applyMp(lambda x: x**2)    | head() | deref() # 700ms</span>
<span class="sd">    range(10000) | applyMp(lambda x: x**2, 5) | head() | deref() # 300ms</span>

<span class="sd">    # demonstrating there&#39;re no huge penalties even if we want all results at the same time</span>
<span class="sd">    range(10000) | applyMp(lambda x: x**2)    | deref() # 900ms</span>
<span class="sd">    range(10000) | applyMp(lambda x: x**2, 5) | deref() # 1000ms</span>

<span class="sd">The first line will schedule all jobs at once, and thus will require more RAM and</span>
<span class="sd">compute power, even though we discard most of the results anyway (the</span>
<span class="sd">:class:`~k1lib.cli.filt.head` cli). The second line only schedules 5 jobs ahead of</span>
<span class="sd">time, and thus will be extremely more efficient if you don&#39;t need all results right</span>
<span class="sd">away.</span>

<span class="sd">.. note::</span>

<span class="sd">    Remember that every :class:`~k1lib.cli.init.BaseCli` is also a</span>
<span class="sd">    function, meaning that you can do stuff like::</span>

<span class="sd">        # returns [[&#39;ab&#39;, &#39;ac&#39;]]</span>
<span class="sd">        [[&quot;ab&quot;, &quot;cd&quot;, &quot;ac&quot;]] | applyMp(filt(op().startswith(&quot;a&quot;)) | deref()) | deref()</span>

<span class="sd">    Also remember that the return result of ``f`` should be serializable, meaning it</span>
<span class="sd">    should not be a generator. That&#39;s why in the example above, there&#39;s a ``deref()``</span>
<span class="sd">    inside f. You should also convert PyTorch tensors into Numpy arrays</span>

<span class="sd">Most of the time, you would probably want to specify ``bs`` to something bigger than 1</span>
<span class="sd">(may be 32 or sth like that). This will executes ``f`` multiple times in a single job,</span>
<span class="sd">instead of executing ``f`` only once per job. Should reduce overhead of process</span>
<span class="sd">creation dramatically.</span>

<span class="sd">If you encounter strange errors not seen on :class:`apply`, you can try to clear all</span>
<span class="sd">pools (using :meth:`clearPools`), to terminate all child processes and thus free</span>
<span class="sd">resources. On earlier versions, you have to do this manually before exiting, but now</span>
<span class="sd">:class:`applyMp` is much more robust.</span>

<span class="sd">Also, you should not immediately assume that :class:`applyMp` will always be faster</span>
<span class="sd">than :class:`apply`. Remember that :class:`applyMp` will create new processes,</span>
<span class="sd">serialize and transfer data to them, execute it, then transfer data back. If your code</span>
<span class="sd">transfers a lot of data back and forth (compared to the amount of computation done), or</span>
<span class="sd">the child processes don&#39;t have a lot of stuff to do before returning, it may very well</span>
<span class="sd">be a lot slower than :class:`apply`.</span>

<span class="sd">There&#39;s a potential loophole here that can make your code faster. Because the main</span>
<span class="sd">process is forked (at least on linux), every variable is still there, even the big</span>
<span class="sd">ones. So, you can potentially do something like this::</span>

<span class="sd">    bigData = [] # 1B items in the list</span>
<span class="sd">    # summing up all items together. No input data transfers (because it&#39;s forked instead)</span>
<span class="sd">    range(1_000_000_000) | batched(100) | applyMp(lambda r: r | apply(lambda i: bigData[i]) | toSum()) | toSum()</span>

<span class="sd">In fact, I use this loophole all the time, and thus has made the function :meth:`shared`,</span>
<span class="sd">so check it out.</span>

<span class="sd">:param prefetch: if not specified, schedules all jobs at the same time. If</span>
<span class="sd">    specified, schedules jobs so that there&#39;ll only be a specified amount of</span>
<span class="sd">    jobs, and will only schedule more if results are actually being used.</span>
<span class="sd">:param timeout: seconds to wait for job before raising an error</span>
<span class="sd">:param utilization: how many percent cores are we running? 0 for no cores, 1 for</span>
<span class="sd">    all the cores. Defaulted to 0.8</span>
<span class="sd">:param bs: if specified, groups ``bs`` number of transforms into 1 job to be more</span>
<span class="sd">    efficient.</span>
<span class="sd">:param kwargs: extra arguments to be passed to the function. ``args`` not</span>
<span class="sd">    included as there&#39;re a couple of options you can pass for this cli.</span>
<span class="sd">:param newPoolEvery: creates a new processing pool for every specific amount of input</span>
<span class="sd">    fed. 0 for not refreshing any pools at all. Turn this on in case your process consumes</span>
<span class="sd">    lots of memory and you have to kill them eventually to free up some memory&quot;&quot;&quot;</span> <span class="c1"># applyMp</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fs</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">]);</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">fastF</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>                              <span class="c1"># applyMp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefetch</span> <span class="o">=</span> <span class="n">prefetch</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>                                     <span class="c1"># applyMp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">utilization</span> <span class="o">=</span> <span class="n">utilization</span>                   <span class="c1"># applyMp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bs</span> <span class="o">=</span> <span class="n">bs</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="kc">None</span>                        <span class="c1"># applyMp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newPoolEvery</span> <span class="o">=</span> <span class="n">newPoolEvery</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span> <span class="o">=</span> <span class="p">[];</span> <span class="bp">self</span><span class="o">.</span><span class="n">_serializeF</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># applyMp</span></div>
<div class="viewcode-block" id="applyMp.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyMp.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">:</span><span class="n">Iterator</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>                        <span class="c1"># applyMp</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">;</span> <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="c1"># really make sure it&#39;s an iterator, for prefetch # applyMp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">it</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">batched</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bs</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="o">|</span> <span class="n">applyMp</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">toList</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefetch</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">joinStreams</span><span class="p">()</span> <span class="c1"># applyMp</span>
        <span class="k">def</span> <span class="nf">newPool</span><span class="p">():</span>                                                           <span class="c1"># applyMp</span>
            <span class="k">if</span> <span class="n">hasTorch</span><span class="p">:</span>                                                         <span class="c1"># applyMp</span>
                <span class="k">try</span><span class="p">:</span> <span class="n">applyMp</span><span class="o">.</span><span class="n">_torchNumThreads</span> <span class="o">=</span> <span class="n">applyMp</span><span class="o">.</span><span class="n">_torchNumThreads</span> <span class="ow">or</span> <span class="n">torch</span><span class="o">.</span><span class="n">get_num_threads</span><span class="p">();</span> <span class="n">torch</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># applyMp</span>
                <span class="k">except</span><span class="p">:</span> <span class="k">pass</span> <span class="c1"># why do all of this? Because some strange interaction between PyTorch and multiprocessing, outlined here: https://github.com/pytorch/pytorch/issues/82843 # applyMp</span>
            <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;py_k1lib_in_applyMp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;True&quot;</span>                           <span class="c1"># applyMp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">utilization</span><span class="p">),</span> <span class="n">terminateGraceful</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="c1"># applyMp</span>
            <span class="k">if</span> <span class="n">hasTorch</span> <span class="ow">and</span> <span class="n">applyMp</span><span class="o">.</span><span class="n">_torchNumThreads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="n">applyMp</span><span class="o">.</span><span class="n">_torchNumThreads</span><span class="p">)</span> <span class="c1"># applyMp</span>
        <span class="k">def</span> <span class="nf">intercept</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>                                                    <span class="c1"># applyMp</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>                                           <span class="c1"># applyMp</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>                                                   <span class="c1"># applyMp</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">();</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="c1"># applyMp</span>
                    <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">();</span> <span class="n">newPool</span><span class="p">()</span>                                      <span class="c1"># applyMp</span>
                <span class="k">yield</span> <span class="n">e</span>                                                          <span class="c1"># applyMp</span>
        <span class="n">common</span> <span class="o">=</span> <span class="n">dill</span><span class="o">.</span><span class="n">dumps</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">])</span>                                    <span class="c1"># applyMp</span>
        <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>                                                             <span class="c1"># applyMp</span>
            <span class="k">with</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">captureStdout</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>                        <span class="c1"># applyMp</span>
                <span class="k">try</span><span class="p">:</span>                                                             <span class="c1"># applyMp</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">newPoolEvery</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">it</span> <span class="o">=</span> <span class="n">intercept</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">newPoolEvery</span><span class="p">)</span> <span class="c1"># applyMp</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">newPool</span><span class="p">()</span>                                              <span class="c1"># applyMp</span>
                    <span class="n">fs</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>                                                 <span class="c1"># applyMp</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefetch</span><span class="p">),</span> <span class="n">it</span><span class="p">):</span>                <span class="c1"># applyMp</span>
                        <span class="n">fs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">executeFunc</span><span class="p">,</span> <span class="p">[</span><span class="n">common</span><span class="p">,</span> <span class="n">dill</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">line</span><span class="p">)]))</span> <span class="c1"># applyMp</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>                                              <span class="c1"># applyMp</span>
                        <span class="k">yield</span> <span class="n">fs</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>                          <span class="c1"># applyMp</span>
                        <span class="n">fs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">executeFunc</span><span class="p">,</span> <span class="p">[</span><span class="n">common</span><span class="p">,</span> <span class="n">dill</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">line</span><span class="p">)]))</span> <span class="c1"># applyMp</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fs</span><span class="p">:</span> <span class="k">yield</span> <span class="n">f</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>                            <span class="c1"># applyMp</span>
                <span class="k">except</span> <span class="ne">KeyboardInterrupt</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>                                   <span class="c1"># applyMp</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;applyMp interrupted. Terminating pool now&quot;</span><span class="p">)</span>           <span class="c1"># applyMp</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">();</span> <span class="n">p</span><span class="o">.</span><span class="n">terminate</span><span class="p">();</span>                  <span class="c1"># applyMp</span>
                    <span class="k">raise</span> <span class="n">e</span>                                                      <span class="c1"># applyMp</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>                                           <span class="c1"># applyMp</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;applyMp encounter errors. Terminating pool now&quot;</span><span class="p">)</span>      <span class="c1"># applyMp</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">();</span> <span class="n">p</span><span class="o">.</span><span class="n">terminate</span><span class="p">();</span>                  <span class="c1"># applyMp</span>
                    <span class="k">raise</span> <span class="n">e</span>                                                      <span class="c1"># applyMp</span>
                <span class="k">else</span><span class="p">:</span>                                                            <span class="c1"># applyMp</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">();</span> <span class="n">p</span><span class="o">.</span><span class="n">terminate</span><span class="p">();</span>                  <span class="c1"># applyMp</span>
        <span class="k">return</span> <span class="n">gen</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>                                                           <span class="c1"># applyMp</span></div>
<div class="viewcode-block" id="applyMp.cat"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyMp.cat">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyMp</span>
    <span class="k">def</span> <span class="nf">cat</span><span class="p">(</span><span class="n">fileName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span><span class="n">Callable</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>           <span class="c1"># applyMp</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like :meth:`applyCl.cat`, this will split a file up into multiple</span>
<span class="sd">sections, execute ``f`` over all sections and return the results.</span>
<span class="sd">Example::</span>

<span class="sd">    fn = &quot;~/repos/labs/k1lib/k1lib/cli/test/applyMp.cat&quot;</span>
<span class="sd">    &quot;0123456789\\n&quot;*100 | file(fn)</span>
<span class="sd">    # returns [6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 8]</span>
<span class="sd">    applyMp.cat(fn, shape(0), 16) | deref()</span>

<span class="sd">:param f: function to execute on an iterator of lines</span>
<span class="sd">:param n: how many chunks should it split the file into. Defaulted to the number of cpu cores available</span>
<span class="sd">:param rS: :class:`~k1lib.cli.inp.refineSeek` instance, if you need more fine-grained</span>
<span class="sd">    control over section boundaries so as to not make everything corrupted</span>
<span class="sd">:param kwargs: extra keyword arguments for :class:`applyMp`&quot;&quot;&quot;</span>                   <span class="c1"># applyMp</span>
        <span class="k">return</span> <span class="n">fileName</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">splitSeek</span><span class="p">(</span><span class="n">n</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span> <span class="o">|</span> <span class="p">(</span><span class="n">rS</span> <span class="ow">or</span> <span class="n">cli</span><span class="o">.</span><span class="n">iden</span><span class="p">())</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">window</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">applyMp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">cli</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="n">sB</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">eB</span><span class="o">=</span><span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># applyMp</span></div>
<div class="viewcode-block" id="applyMp.shared"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyMp.shared">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyMp</span>
    <span class="k">def</span> <span class="nf">shared</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>                                                     <span class="c1"># applyMp</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execution model where the input iterator is dereferenced and shared across</span>
<span class="sd">all processes, bypassing serialization. Example::</span>

<span class="sd">    a = range(1_000_000_000) | apply(lambda x: x*1.5 - 2000) | aS(list) # giant data structure</span>
<span class="sd">    a | batched(50_000_000, True) | applyMp(toSum()) | toSum() # has to serialize and deserialize lists of numbers, which wastes lots of cpu cycles and memory</span>
<span class="sd">    a | applyMp.shared(toSum()) | toSum() # giant data structure is forked, no serialization happens, no memory even gets copied, much faster</span>

<span class="sd">In the 2nd line, most of the time is spent on serializing the data and transferring</span>
<span class="sd">it to other processes, while in the 3rd line, most of the time is spent on calculating</span>
<span class="sd">the sum instead, as the giant data structure is forked, and Linux doesn&#39;t copy it internally.&quot;&quot;&quot;</span> <span class="c1"># applyMp</span>
        <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>                                                           <span class="c1"># applyMp</span>
            <span class="k">try</span><span class="p">:</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>                                                     <span class="c1"># applyMp</span>
            <span class="k">except</span><span class="p">:</span> <span class="n">it</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>                                   <span class="c1"># applyMp</span>
            <span class="c1"># this is pretty unintuitive right? Why do it this way? Turns out, if you were to reference `it` directly, it will store it in f&#39;s co_freevars, # applyMp</span>
            <span class="c1"># which will be serialized, defeating the purpose. Moving it to a global variable forces it to move to co_names instead, avoiding serialization. This took forever to understand # applyMp</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">_k1_applyMp_global_ctx_autoInc</span><span class="p">();</span> <span class="n">_k1_applyMp_global_ctx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">it</span> <span class="c1"># applyMp</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">batched</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span> <span class="o">|</span> <span class="n">applyMp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">_k1_applyMp_global_ctx</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">r</span><span class="o">.</span><span class="n">stop</span><span class="p">]),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">|</span> <span class="n">aS</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> <span class="c1"># applyMp</span>
            <span class="n">_k1_applyMp_global_ctx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span> <span class="k">return</span> <span class="n">res</span>                       <span class="c1"># applyMp</span>
        <span class="k">return</span> <span class="n">aS</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>                                                         <span class="c1"># applyMp</span></div>
    <span class="k">def</span> <span class="nf">_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">applyMp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefetch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">utilization</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">newPoolEvery</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># applyMp</span>
<div class="viewcode-block" id="applyMp.__invert__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyMp.__invert__">[docs]</a>    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                                                        <span class="c1"># applyMp</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expands the arguments out, just like :class:`apply`.</span>
<span class="sd">Example::</span>

<span class="sd">    # returns [20, 20, 18, 14, 8, 0, -10, -22, -36, -52]</span>
<span class="sd">    [range(10), range(20, 30)] | transpose() | ~applyMp(lambda x, y: y-x**2) | deref()&quot;&quot;&quot;</span> <span class="c1"># applyMp</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">();</span> <span class="n">f</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">f</span><span class="p">;</span> <span class="n">res</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">);</span> <span class="k">return</span> <span class="n">res</span>       <span class="c1"># applyMp</span></div>
<div class="viewcode-block" id="applyMp.clearPools"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyMp.clearPools">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyMp</span>
    <span class="k">def</span> <span class="nf">clearPools</span><span class="p">():</span>                                                            <span class="c1"># applyMp</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Terminate all existing pools. Do this before restarting/quitting the</span>
<span class="sd">script/notebook to make sure all resources (like GPU) are freed. **Update**:</span>
<span class="sd">you probably won&#39;t have to call this manually anymore since version 0.9, but</span>
<span class="sd">if you run into problems, try doing this.&quot;&quot;&quot;</span>                                     <span class="c1"># applyMp</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">applyMp</span><span class="o">.</span><span class="n">_pools</span><span class="p">:</span>                                                 <span class="c1"># applyMp</span>
            <span class="k">try</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>                                                   <span class="c1"># applyMp</span>
            <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>                                                         <span class="c1"># applyMp</span>
        <span class="n">applyMp</span><span class="o">.</span><span class="n">_pools</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>                                                   <span class="c1"># applyMp</span></div>
<div class="viewcode-block" id="applyMp.pools"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyMp.pools">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyMp</span>
    <span class="k">def</span> <span class="nf">pools</span><span class="p">():</span>                                                                 <span class="c1"># applyMp</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get set of all pools. Meant for debugging purposes only.&quot;&quot;&quot;</span>           <span class="c1"># applyMp</span>
        <span class="k">return</span> <span class="n">applyMp</span><span class="o">.</span><span class="n">_pools</span>                                                    <span class="c1"># applyMp</span></div>
    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                                                           <span class="c1"># applyMp</span>
        <span class="k">return</span>                                                                   <span class="c1"># applyMp</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">):</span>                                                   <span class="c1"># applyMp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">terminate</span><span class="p">();</span>                                                  <span class="c1"># applyMp</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="ow">in</span> <span class="n">applyMp</span><span class="o">.</span><span class="n">_pools</span><span class="p">:</span> <span class="n">applyMp</span><span class="o">.</span><span class="n">_pools</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>           <span class="c1"># applyMp</span></div>
<span class="c1"># apparently, this doesn&#39;t do anything, at least in jupyter environment          # applyMp</span>
<span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">applyMp</span><span class="o">.</span><span class="n">clearPools</span><span class="p">())</span>                                    <span class="c1"># applyMp</span>
<span class="n">parallel</span> <span class="o">=</span> <span class="n">applyMp</span>                                                               <span class="c1"># applyMp</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">Settings</span><span class="p">();</span> <span class="n">settings</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;applyCl&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s2">&quot;modifier.applyCl() settings&quot;</span><span class="p">)</span>  <span class="c1"># applyMp</span>
<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;sudoTimeout&quot;</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="s2">&quot;seconds before deleting the stored password for sudo commands&quot;</span><span class="p">)</span> <span class="c1"># applyMp</span>
<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;cpuLimit&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;if specified (int), will not schedule more jobs if the current number of assigned cpus exceeds this&quot;</span><span class="p">)</span> <span class="c1"># applyMp</span>
<span class="n">_password</span> <span class="o">=</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">Wrapper</span><span class="p">(</span><span class="kc">None</span><span class="p">);</span> <span class="n">_cpuUsed</span> <span class="o">=</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">Wrapper</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                     <span class="c1"># applyMp</span>
<span class="k">def</span> <span class="nf">removePw</span><span class="p">():</span>                                                                  <span class="c1"># removePw</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">applyCl</span><span class="o">.</span><span class="n">sudoTimeout</span><span class="p">);</span> <span class="n">_password</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># removePw</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">removePw</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>                       <span class="c1"># removePw</span>
<span class="n">_nodeIdsCache</span> <span class="o">=</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">Wrapper</span><span class="p">([])</span>                                                <span class="c1"># removePw</span>
<span class="k">def</span> <span class="nf">specificNode</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nodeId</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">num_gpus</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="c1"># modify a function so that it will only run on a specific node only # specificNode</span>
    <span class="k">if</span> <span class="n">num_gpus</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">num_gpus</span><span class="o">=</span><span class="n">num_gpus</span><span class="p">,</span> <span class="n">scheduling_strategy</span><span class="o">=</span><span class="s2">&quot;SPREAD&quot;</span><span class="p">)</span> <span class="c1"># specificNode</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">scheduling_strategy</span><span class="o">=</span><span class="n">ray</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">scheduling_strategies</span><span class="o">.</span><span class="n">NodeAffinitySchedulingStrategy</span><span class="p">(</span><span class="n">node_id</span><span class="o">=</span><span class="n">nodeId</span><span class="p">,</span> <span class="n">soft</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span> <span class="c1"># specificNode</span>
<span class="k">def</span> <span class="nf">exportSe</span><span class="p">(</span><span class="n">se</span><span class="p">):</span>                                                                <span class="c1"># exportSe</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">Settings</span><span class="p">):</span> <span class="k">return</span> <span class="n">se</span>                             <span class="c1"># exportSe</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">exportSe</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">se</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)}</span> <span class="c1"># exportSe</span>
<span class="k">def</span> <span class="nf">movePropsSe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">se</span><span class="p">):</span>                                                        <span class="c1"># movePropsSe</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">se</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">;</span> <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]</span>       <span class="c1"># movePropsSe</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>                                                             <span class="c1"># movePropsSe</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span> <span class="k">continue</span>                                              <span class="c1"># movePropsSe</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">Settings</span><span class="p">):</span> <span class="n">movePropsSe</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>     <span class="c1"># movePropsSe</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>                                                  <span class="c1"># movePropsSe</span>
<span class="n">_applyCl_soCache</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># dynamic library (.so) that has been installed across all nodes, so don&#39;t have to reimport # movePropsSe</span>
<div class="viewcode-block" id="applyCl"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl">[docs]</a><span class="k">class</span> <span class="nc">applyCl</span><span class="p">(</span><span class="n">BaseCli</span><span class="p">):</span>                                                          <span class="c1"># applyCl</span>
<div class="viewcode-block" id="applyCl.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">prefetch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">bs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rss</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">{},</span> <span class="n">pre</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_cpus</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_gpus</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolve</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like :class:`apply`, but execute a function over the input iterator</span>
<span class="sd">in multiple processes on multiple nodes inside of a cluster (hence &quot;cl&quot;). So, just a more</span>
<span class="sd">powerful version of :class:`applyMp`, assuming you have a cluster to run it on.</span>
<span class="sd">Example::</span>

<span class="sd">    # returns [3, 2]</span>
<span class="sd">    [&quot;abc&quot;, &quot;de&quot;] | applyCl(len) | deref()</span>
<span class="sd">    # returns [5, 6, 9]</span>
<span class="sd">    range(3) | applyCl(lambda x, bias: x**2+bias, bias=5) | deref()</span>

<span class="sd">    # returns [[1, 2, 3], [1, 2, 3]], demonstrating outside vars work</span>
<span class="sd">    someList = [1, 2, 3]</span>
<span class="sd">    [&quot;abc&quot;, &quot;de&quot;] | applyCl(lambda s: someList) | deref()</span>

<span class="sd">    nIds = applyCl.nodeIds()</span>
<span class="sd">    # returns [[&lt;nodeId1&gt;, 0], [&lt;nodeId2&gt;, 1], ...], demonstrating preserve mode</span>
<span class="sd">    [nIds, range(10)] | transpose() | applyCl(lambda x: x**2, pre=True) | deref()</span>

<span class="sd">    # executes the function, but stores the result on remote nodes, instead of copying result to this node</span>
<span class="sd">    a = range(5) | applyCl(lambda x: x**2, resolve=False) | deref()</span>
<span class="sd">    # returns [0, 1, 4, 9, 16]</span>
<span class="sd">    a | applyCl(lambda x: x) | deref()</span>

<span class="sd">Summary of all mode of operations::</span>

<span class="sd">    # Data types:</span>
<span class="sd">    # - 1:   literal value, just a normal Python object</span>
<span class="sd">    # - or1: ray.ObjectRef object - Ray&#39;s reference to a remote object living somewhere</span>
<span class="sd">    # - h1:  Handle        object - k1lib&#39;s reference to a remote object, obtained if `resolve` is set to False. Use `h.get()` to</span>
<span class="sd">    # - n1:  node id, string</span>

<span class="sd">    [1/or1/h1, 2/or2/h2] | applyCl(...)                                              # returns [1, 2, 3]. &quot;1/or1/h1&quot; means that the input can be a list of literals, ObjectRef, or Handle</span>
<span class="sd">    [1/or1/h1, 2/or2/h2] | applyCl(..., resolve=False)                               # returns [h1, h2, h3]</span>
<span class="sd">    [[n1/h1,   1/or1/h3], [n2/h2, 2/or2/h4]] | applyCl(..., pre=True)                # returns [[n1/h1, 1],  [n2/h2, 2]], executed on n1/h1, h3 is copied over</span>
<span class="sd">    [[n1/h1,   1/or1/h3], [n2/h2, 2/or2/h4]] | applyCl(..., pre=True, resolve=False) # returns [[n1/h1, h3], [n2/h2, h4]]</span>

<span class="sd">    [n1, n2] | applyCl.aS(lambda: ...)                # returns [[n1, 1],  [n2, 2]]</span>
<span class="sd">    None     | applyCl.aS(lambda: ...)                # returns [[n1, 1],  [n2, 2], ...], executes once on all nodes</span>
<span class="sd">    [n1, n2] | applyCl.aS(lambda: ..., resolve=False) # returns [[n1, h1], [n2, h2]]</span>

<span class="sd">Internally, this uses the library Ray (https://www.ray.io) to do the heavy</span>
<span class="sd">lifting. So, :class:`applyCl` can be thought of as a thin wrapper around that</span>
<span class="sd">library, but still has the same consistent interface as :class:`apply` and</span>
<span class="sd">:class:`applyMp`. From all of my tests so far, it seems that :class:`applyCl`</span>
<span class="sd">works quite well and is quite robust, so if you have access to a cluster, use</span>
<span class="sd">it over :class:`applyMp`.</span>

<span class="sd">The library will connect to a Ray cluster automatically when you import</span>
<span class="sd">everything using ``from k1lib.imports import *``. It will execute</span>
<span class="sd">``import ray; ray.init()``, which is quite simple. If you have ray installed,</span>
<span class="sd">but does not want this default behavior, you can do this::</span>

<span class="sd">    import k1lib</span>
<span class="sd">    k1lib.settings.startup.init_ray = False</span>
<span class="sd">    from k1lib.imports import *</span>

<span class="sd">As with :class:`applyMp`, there are pitfalls and weird quirks to multiprocessing,</span>
<span class="sd">on 1 or multiple nodes, so check out the docs over there to be aware of them,</span>
<span class="sd">as those translates well to here.</span>

<span class="sd">There&#39;re more extensive documentation on these notebooks: `27-multi-node &lt;https://mlexps.com/other/27-multi-node/&gt;`_,</span>
<span class="sd">`30-applyCl-benchmarks &lt;https://mlexps.com/other/30-applyCl-benchmarks/&gt;`_, if you want to kinda get the feel of this</span>
<span class="sd">tool more.</span>

<span class="sd">.. admonition:: Time sharing the cluster</span>

<span class="sd">    Let&#39;s say that the cluster is located in a company, and that multiple users want to</span>
<span class="sd">    access it, then you might have to think about it a little more. Say the cluster has</span>
<span class="sd">    60 cores, and someone has launched a long-running job: 2160 tasks, 10 minutes/task,</span>
<span class="sd">    1 core/task, totalling 6 hours. If you want to launch another job that has 20 tasks,</span>
<span class="sd">    requiring 10 cores, 1 second/task, totalling 2 seconds on an idle cluster.</span>

<span class="sd">    All modern schedulers (Ray, Slurm, Spark, etc) can&#39;t schedule your 20 tasks immediately.</span>
<span class="sd">    It has to wait for some running tasks to finish to schedule your task. This means you</span>
<span class="sd">    have to wait on average for 5-10 minutes before all of your tasks finish. This might be</span>
<span class="sd">    fine if you&#39;ve used Slurm a lot, but extremely not okay for me and my patience. The whole</span>
<span class="sd">    point of a cluster is to get results immediately, within a few seconds. So here&#39;s a</span>
<span class="sd">    workaround::</span>

<span class="sd">        # long running task, on notebook 1</span>
<span class="sd">        from k1lib.imports import *</span>
<span class="sd">        settings.cli.applyCl.cpuLimit = 40</span>
<span class="sd">        range(2160) | applyCl(lambda x: time.sleep(10*60)) | ignore() # long running task</span>

<span class="sd">        # short running task, on notebook 2</span>
<span class="sd">        from k1lib.imports import *</span>
<span class="sd">        range(20) | applyCl(lambda x: time.sleep(1)) | ignore() # short running task, should finishes almost immediately</span>

<span class="sd">    Essentially, there&#39;s that setting that you can adjust. Like with Ray&#39;s ``num_cpus``,</span>
<span class="sd">    this is merely a suggestion to my library to not schedule jobs past that cpu limit,</span>
<span class="sd">    but you can circumvent it in some strange edge cases that I&#39;m too lazy to implement.</span>
<span class="sd">    Likewise, when you schedule a Ray task, you can specify that it will only take 1 cpu,</span>
<span class="sd">    but you can end up forking it into 5 different processes, which can cause congestion</span>
<span class="sd">    and memory thrashing. If Ray doesn&#39;t do it right (possibly impossible to do so anyway)</span>
<span class="sd">    then do I really have to?</span>

<span class="sd">.. admonition:: Advanced use case</span>

<span class="sd">    Not really advanced, but just a bit difficult to understand/follow. Let&#39;s say</span>
<span class="sd">    that you want to scan through the home directory of all nodes, grab all files,</span>
<span class="sd">    read them, and get the number of bytes they have. You can do something like this::</span>

<span class="sd">        a = None | applyCl.aS(lambda: None | cmd(&quot;ls ~&quot;) | filt(os.path.isfile) | deref()) | deref()</span>
<span class="sd">        b = a | ungroup() | deref()</span>
<span class="sd">        c = b | applyCl(cat(text=False) | shape(0), pre=True) | deref()</span>
<span class="sd">        d = c | groupBy(0, True) | apply(item().all() | toSum(), 1) | deref()</span>

<span class="sd">    Noted, this is relatively complex. Let&#39;s see what A, B, C and D looks like::</span>

<span class="sd">        # A</span>
<span class="sd">        [[&#39;7bb387b2920694abe9f7d2a2ed939b6d31843faf91d174d0221e871d&#39;, [&#39;Miniconda3-latest-Linux-x86_64.sh&#39;, &#39;mintupgrade-2023-04-01T232950.log&#39;]],</span>
<span class="sd">         [&#39;1051dafd2b0dac13561c46fe052f561400592f0723df2cd746a41068&#39;, [&#39;5a&#39;, &#39;abc.jpg&#39;, &#39;a.txt&#39;]]]</span>
<span class="sd">        # B</span>
<span class="sd">        [[&#39;7bb387b2920694abe9f7d2a2ed939b6d31843faf91d174d0221e871d&#39;, &#39;Miniconda3-latest-Linux-x86_64.sh&#39;],</span>
<span class="sd">         [&#39;7bb387b2920694abe9f7d2a2ed939b6d31843faf91d174d0221e871d&#39;, &#39;mintupgrade-2023-04-01T232950.log&#39;],</span>
<span class="sd">         [&#39;1051dafd2b0dac13561c46fe052f561400592f0723df2cd746a41068&#39;, &#39;5a&#39;],</span>
<span class="sd">         [&#39;1051dafd2b0dac13561c46fe052f561400592f0723df2cd746a41068&#39;, &#39;abc.jpg&#39;],</span>
<span class="sd">         [&#39;1051dafd2b0dac13561c46fe052f561400592f0723df2cd746a41068&#39;, &#39;a.txt&#39;]]</span>
<span class="sd">        # C</span>
<span class="sd">        [[&#39;7bb387b2920694abe9f7d2a2ed939b6d31843faf91d174d0221e871d&#39;, 74403966],</span>
<span class="sd">         [&#39;7bb387b2920694abe9f7d2a2ed939b6d31843faf91d174d0221e871d&#39;, 1065252],</span>
<span class="sd">         [&#39;1051dafd2b0dac13561c46fe052f561400592f0723df2cd746a41068&#39;, 2601],</span>
<span class="sd">         [&#39;1051dafd2b0dac13561c46fe052f561400592f0723df2cd746a41068&#39;, 16341],</span>
<span class="sd">         [&#39;1051dafd2b0dac13561c46fe052f561400592f0723df2cd746a41068&#39;, 10177]]</span>
<span class="sd">        # D</span>
<span class="sd">        [[&#39;1051dafd2b0dac13561c46fe052f561400592f0723df2cd746a41068&#39;, 92185432],</span>
<span class="sd">         [&#39;7bb387b2920694abe9f7d2a2ed939b6d31843faf91d174d0221e871d&#39;, 75469218]]</span>

<span class="sd">    The steps we&#39;re concerned with is A and C. In step A, we&#39;re running 2 processes, 1 for each</span>
<span class="sd">    node, to get all the file names in the home directory. In step C, we&#39;re running 5 processes</span>
<span class="sd">    total, 2 on the first node and 3 on the second node. For each process, it&#39;s going to read as</span>
<span class="sd">    bytes and count up those bytes. Finally in step D, the results are grouped together and the</span>
<span class="sd">    sizes summed.</span>

<span class="sd">    So yeah, it&#39;s pretty nice that we did all of that in a relatively short amount of code.</span>
<span class="sd">    The data is distributed too (reading multiple files from multiple nodes), so we&#39;re truly</span>
<span class="sd">    not bottlenecked by anything.</span>

<span class="sd">.. admonition:: Context object handle</span>

<span class="sd">    Let&#39;s say you have these unresolved handles::</span>

<span class="sd">        # creates a bunch of infinite random number generators, one on each node</span>
<span class="sd">        its = None | applyCl.aS(lambda: repeatF(lambda: random.randint(2, 15)), resolve=False) | deref()</span>
<span class="sd">        # gets the next value of all generators, can return [4, 4, 9, 2] for a 4-node cluster</span>
<span class="sd">        its | cut(1) | applyCl(lambda x: next(x)) | deref()</span>
<span class="sd">        # gets the next value of all generators, add 0 to the 1st generator, 1 to the 2nd generator, etc, then return the resulting output that might look like [3, 16, 10, 7]</span>
<span class="sd">        [its | cut(1), range(4)] | transpose() | applyCl(lambda x: next(ctxHandle) + x, pre=True) | cut(1) | deref()</span>

<span class="sd">    So, the special thing about this is that variable `ctxHandle` on the last line. That is a</span>
<span class="sd">    special variable that is injected on the way. Why all this complexity?</span>

<span class="sd">    The whole idea with unresolved object handles is that you have a distributed complex</span>
<span class="sd">    data structure that can&#39;t be serialized and juggle around easily. That&#39;s the `its` handles</span>
<span class="sd">    in the example. Then, you might want to feed in some (simple, serializable) input X,</span>
<span class="sd">    change the complex data structure in its own process, then return some (simple, serializable)</span>
<span class="sd">    output Y. In the example, X is range(4), while Y is the resulting number array.</span>

<span class="sd">.. admonition:: Cython</span>

<span class="sd">    Even with running everything distributedly like this, you might run into speed issues.</span>
<span class="sd">    Then, you&#39;ll essentially have 2 options. First is to write (pleasant) Cython code, or</span>
<span class="sd">    second is to write (unpleasant) C/C++ Python extensions. If you were to choose the C/C++</span>
<span class="sd">    option, then here&#39;s the flow:</span>

<span class="sd">    - Develop Python C extension, export everything as a shared library (a single .so file)</span>
<span class="sd">    - Execute ``applyCl.installSo(&quot;library.so&quot;)`` to install the library to all nodes</span>
<span class="sd">    - Use functions provided by your library normally, like ``import yourlibrary; range(10) | applyCl(yourlibrary.afunction) | deref()``</span>

<span class="sd">    But applyCl can deal with cython functions directly in your notebook. Here&#39;s the flow:</span>

<span class="sd">    - Annotate a code cell with the magic &quot;%%cython&quot;, write Cython code as usual</span>
<span class="sd">    - Just use that function normally</span>

<span class="sd">    Let&#39;s see an example::</span>

<span class="sd">        # ---------- code cell 1 ----------</span>
<span class="sd">        from k1lib.imports import *      # cython ipython extension is automatically loaded</span>
<span class="sd">        # ---------- code cell 2 ----------</span>
<span class="sd">        %%cython</span>
<span class="sd">        from k1lib.cli import ls         # demonstrating that you can use all of the existing tools and libraries as usual</span>
<span class="sd">        cdef g(a:int): return f&quot;{a} 123&quot; # demonstrating that you can refactor out to other functions</span>
<span class="sd">        def f (a:int): return [g(a), ls(&quot;.&quot;)]</span>
<span class="sd">        # ---------- code cell 3 ----------</span>
<span class="sd">        range(10) | applyCl(f) | deref()</span>

<span class="sd">    You only have to install Cython on the current node and not the other nodes. Also note</span>
<span class="sd">    that currently, this only supports you passing in Cython-compiled functions directly into</span>
<span class="sd">    ``applyCl()`` or ``applyCl.aS()``. You can&#39;t pass a normal Python function that uses a</span>
<span class="sd">    Cython function like this::</span>

<span class="sd">        # ---------- code cell 1 ----------</span>
<span class="sd">        from k1lib.imports import *</span>
<span class="sd">        # ---------- code cell 2 ----------</span>
<span class="sd">        %%cython</span>
<span class="sd">        from k1lib.cli import ls          # note: have to reimport here because all the symbols inside this code block is independent from the rest of the notebook</span>
<span class="sd">        cpdef g(a:int): return f&quot;{a} 123&quot;</span>
<span class="sd">        # ---------- code cell 3 ----------</span>
<span class="sd">        def f (a:int): return [g(a), ls(&quot;.&quot;)]</span>
<span class="sd">        range(10) | applyCl(f) | deref() # this throws an import error, as the compiled code won&#39;t be installed on the remote nodes</span>

<span class="sd">    This behavior can potentially be fixed in the future, but I&#39;m lazy and it&#39;s not a hard</span>
<span class="sd">    thing to follow the rules. The dynamic library will be installed in the working directory.</span>
<span class="sd">    You can delete them after a coding session to free up some space, but they&#39;re likely to be</span>
<span class="sd">    tiny, so you don&#39;t really have to worry about it.</span>

<span class="sd">    Also, like everything else in parallel programming, please benchmark absolutely everything</span>
<span class="sd">    because it might even be slower using Cython if internally you&#39;re allocating space for</span>
<span class="sd">    large data structures constantly, compared to cli tool&#39;s lazy execution model. For operations</span>
<span class="sd">    that work on giant files, I actually find it very difficult to gain any appreciable speedups</span>
<span class="sd">    using Cython, as cli tools are already pretty optimized, so best task for this is probably</span>
<span class="sd">    long-running, complex mathematical modelling, and not generic text manipulation.</span>

<span class="sd">.. warning::</span>

<span class="sd">    Just like with any other parallel processing model, there are some quirks that</span>
<span class="sd">    can happen behind the scenes that aren&#39;t quite what you expected, as this is</span>
<span class="sd">    incredibly tricky. Dig into Ray&#39;s serialization page (https://docs.ray.io/en/latest/ray-core/objects/serialization.html)</span>
<span class="sd">    or their whitepapers (https://docs.ray.io/en/latest/ray-contribute/whitepaper.html)</span>
<span class="sd">    to get a feel for how it all works underneath. The notable quirks that you might need to think about is:</span>

<span class="sd">    - A lot of the internal code assumes that you&#39;re on a Unix system, preferably Linux,</span>
<span class="sd">      so it might not work on other platforms like Windows. But honestly, screw Windows.</span>

<span class="sd">:param prefetch: if not specified, schedules all jobs at the same time. If</span>
<span class="sd">    specified, schedules jobs so that there&#39;ll only be a specified amount of</span>
<span class="sd">    jobs, and will only schedule more if results are actually being used.</span>
<span class="sd">:param timeout: seconds to wait for job before raising an error</span>
<span class="sd">:param bs: if specified, groups ``bs`` number of transforms into 1 job to be more</span>
<span class="sd">    efficient.</span>
<span class="sd">:param rss: resources required for the task. Can be {&quot;custom_resource1&quot;: 2} or &quot;custom_resource1&quot; as a shortcut</span>
<span class="sd">:param pre: &quot;preserve&quot;, same convention as :meth:`applyCl.aS`. If True, then allow passing</span>
<span class="sd">    through node ids as the first column to shedule jobs on those specific nodes only</span>
<span class="sd">:param num_cpus: how many cpu does each task take?</span>
<span class="sd">:param memory: how much memory to give to the task in bytes?</span>
<span class="sd">:param resolve: whether to resolve the outputs or not. Set this to False to not move</span>
<span class="sd">    memory to the requesting node and cache the big data structure on the remote node</span>
<span class="sd">:param kwargs: extra arguments to be passed to the function. ``args`` not</span>
<span class="sd">    included as there&#39;re a couple of options you can pass for this cli.&quot;&quot;&quot;</span>       <span class="c1"># applyCl</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fs</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">]);</span> <span class="n">_fC</span> <span class="o">=</span> <span class="n">fastF</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">ogF</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cpus</span> <span class="o">=</span> <span class="n">num_cpus</span> <span class="c1"># applyCl</span>
        <span class="k">try</span><span class="p">:</span> <span class="c1"># f might be a string, so can&#39;t do f.__module__                     # applyCl</span>
            <span class="n">isCythonFunc</span> <span class="o">=</span> <span class="s2">&quot;cython&quot;</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="vm">__module__</span>                              <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="n">isCythonFunc</span><span class="p">:</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">installSo</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="vm">__module__</span><span class="p">]</span><span class="o">.</span><span class="vm">__file__</span><span class="p">)</span> <span class="c1"># applyCl</span>
        <span class="k">except</span><span class="p">:</span> <span class="n">isCythonFunc</span> <span class="o">=</span> <span class="kc">False</span>                                             <span class="c1"># applyCl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rss</span> <span class="o">=</span> <span class="n">rss</span> <span class="o">=</span> <span class="p">{</span><span class="n">rss</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rss</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">rss</span>               <span class="c1"># applyCl</span>
        <span class="n">cwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">();</span> <span class="n">se</span> <span class="o">=</span> <span class="n">exportSe</span><span class="p">(</span><span class="n">k1lib</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>                         <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">remoteF</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">idxCtxHandle</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># function that will be executed on remote node. Have to setup environment a little bit before executing # applyCl</span>
            <span class="c1"># e: the real element. s is just e&#39;s storage context, in case e is a Handle. Else s is not used and can be None. Why? Because Actors can&#39;t be # applyCl</span>
            <span class="c1"># serialized directly with cloudpickle, but it can be passed as function parameters, which Ray will do some special sauce serialization # applyCl</span>
            <span class="kn">import</span> <span class="nn">k1lib</span><span class="p">;</span> <span class="n">movePropsSe</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span> <span class="c1"># do this to sync current settings with the remote worker nodes # applyCl</span>
            <span class="k">if</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">startup</span><span class="o">.</span><span class="n">or_patch</span><span class="o">.</span><span class="n">numpy</span><span class="p">:</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">cli</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">patchNumpy</span><span class="p">()</span> <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">startup</span><span class="o">.</span><span class="n">or_patch</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">cli</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">patchDict</span><span class="p">()</span>  <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">startup</span><span class="o">.</span><span class="n">or_patch</span><span class="o">.</span><span class="n">pandas</span><span class="p">:</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">cli</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">patchPandas</span><span class="p">()</span> <span class="c1"># applyCl</span>
            <span class="kn">import</span> <span class="nn">os</span><span class="p">;</span> <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">cwd</span><span class="p">,</span> <span class="n">exist_ok</span> <span class="o">=</span> <span class="kc">True</span><span class="p">);</span> <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">cwd</span><span class="p">)</span>          <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Handle</span><span class="p">):</span> <span class="n">e</span><span class="o">.</span><span class="n">setStorage</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>               <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="n">idxCtxHandle</span><span class="p">:</span> <span class="n">_fC</span><span class="o">.</span><span class="vm">__globals__</span><span class="p">[</span><span class="s2">&quot;ctxHandle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">idxCtxHandle</span><span class="p">]</span>    <span class="c1"># applyCl</span>
            <span class="k">return</span> <span class="n">_fC</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>                                              <span class="c1"># applyCl</span>
        <span class="c1"># self.remoteF = remoteF; f = ray.remote(resources=rss, num_cpus=num_cpus, **({&quot;memory&quot;: memory} if memory else {}))(remoteF) # applyCl</span>
        <span class="n">rssKw</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;resources&quot;</span><span class="p">:</span> <span class="n">rss</span><span class="p">,</span> <span class="s2">&quot;num_cpus&quot;</span><span class="p">:</span> <span class="n">num_cpus</span><span class="p">,</span> <span class="s2">&quot;num_gpus&quot;</span><span class="p">:</span> <span class="n">num_gpus</span><span class="p">,</span> <span class="o">**</span><span class="p">({</span><span class="s2">&quot;memory&quot;</span><span class="p">:</span> <span class="n">memory</span><span class="p">}</span> <span class="k">if</span> <span class="n">memory</span> <span class="k">else</span> <span class="p">{})}</span><span class="c1">#; rssKw = None # applyCl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefetch</span> <span class="o">=</span> <span class="n">prefetch</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e8</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bs</span> <span class="o">=</span> <span class="n">bs</span> <span class="c1"># applyCl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_copyCtx</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">prefetch</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">bs</span><span class="p">,</span> <span class="n">rss</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">num_cpus</span><span class="p">,</span> <span class="n">num_gpus</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">resolve</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">]</span> <span class="c1"># applyCl</span>
        <span class="n">nodeId</span> <span class="o">=</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">nodeId</span><span class="p">();</span> <span class="n">rssF</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="o">**</span><span class="n">rssKw</span><span class="p">)(</span><span class="n">remoteF</span><span class="p">)</span> <span class="c1"># f that has constraints injected into it # applyCl</span>
        <span class="k">def</span> <span class="nf">preprocessF</span><span class="p">(</span><span class="n">e</span><span class="p">):</span> <span class="c1"># return Handle (if pre=False), or [nodeId, Handle] (if pre=True). f is remoteF, core element can be a Handle, real object, or ObjectRef # applyCl</span>
            <span class="k">if</span> <span class="n">resolve</span><span class="p">:</span> <span class="c1"># storage location managed by ray, returns or2/h2 or [nId/h1, or2/h2] # applyCl</span>
                <span class="k">if</span> <span class="n">pre</span><span class="p">:</span>                                                          <span class="c1"># applyCl</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">extractStorage</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>                              <span class="c1"># applyCl</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Handle</span><span class="p">):</span> <span class="n">h</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">executeAsync</span><span class="p">(</span><span class="n">remoteF</span><span class="p">,</span> <span class="n">rssKw</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">idx</span><span class="p">)]</span> <span class="c1"># applyCl</span>
                    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">specificNode</span><span class="p">(</span><span class="n">rssF</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">num_gpus</span><span class="o">=</span><span class="n">num_gpus</span><span class="p">)</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span> <span class="c1"># applyCl</span>
                <span class="k">else</span><span class="p">:</span>                                                            <span class="c1"># applyCl</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Handle</span><span class="p">):</span> <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">executeAsync</span><span class="p">(</span><span class="n">remoteF</span><span class="p">,</span> <span class="n">rssKw</span><span class="p">)</span> <span class="c1"># applyCl</span>
                    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">rssF</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>                            <span class="c1"># applyCl</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># storage location explicitly managed by me, returns h2 or [nId/h1, h2] # applyCl</span>
                <span class="n">storageWarmup</span><span class="p">()</span>                                                  <span class="c1"># applyCl</span>
                <span class="k">if</span> <span class="n">pre</span><span class="p">:</span>                                                          <span class="c1"># applyCl</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">extractStorage</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>                              <span class="c1"># applyCl</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Handle</span><span class="p">):</span> <span class="c1"># [h1, 2/or2/h2]                   # applyCl</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1"># first deposits b into a&#39;s storage context to get handle. h and a have the same storage context # applyCl</span>
                        <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">executeAsync</span><span class="p">(</span><span class="n">remoteF</span><span class="p">,</span> <span class="n">rssKw</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">idx</span><span class="p">)],</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">h</span><span class="p">]</span> <span class="c1"># then executes it in h&#39;s storage context # applyCl</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1"># [nId, 2/or2/h2]                                      # applyCl</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Handle</span><span class="p">)</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">nodeId</span> <span class="o">==</span> <span class="n">nodeId</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">executeAsync</span><span class="p">(</span><span class="n">remoteF</span><span class="p">,</span> <span class="n">rssKw</span><span class="p">)],</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="c1"># [nId, h2], if h2 is on nId, then use h2&#39;s storage context # applyCl</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">Handle</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">num_gpus</span><span class="o">=</span><span class="n">num_gpus</span><span class="p">);</span> <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">executeAsync</span><span class="p">(</span><span class="n">remoteF</span><span class="p">,</span> <span class="n">rssKw</span><span class="p">)],</span> <span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="c1"># create storage context on `a`, deposits b on it, then execute # applyCl</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># 1/or1/h1                                                 # applyCl</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">extractStorage</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>                                        <span class="c1"># applyCl</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Handle</span><span class="p">):</span> <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">executeAsync</span><span class="p">(</span><span class="n">remoteF</span><span class="p">,</span> <span class="n">rssKw</span><span class="p">),</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="c1"># has storage context already, execute on it directly # applyCl</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">h</span> <span class="o">=</span> <span class="n">Handle</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">num_gpus</span><span class="o">=</span><span class="n">num_gpus</span><span class="p">);</span> <span class="k">return</span> <span class="n">h</span><span class="o">.</span><span class="n">executeAsync</span><span class="p">(</span><span class="n">remoteF</span><span class="p">,</span> <span class="n">rssKw</span><span class="p">),</span> <span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="c1"># create storage context, deposit e on it, then execute # applyCl</span>
        <span class="nd">@ray</span><span class="o">.</span><span class="n">remote</span>                                                              <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">resolveFRemote</span><span class="p">(</span><span class="n">o</span><span class="p">):</span> <span class="k">return</span> <span class="mi">1</span>                                          <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">resolveF</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>                                                         <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="n">resolve</span><span class="p">:</span>                                                          <span class="c1"># applyCl</span>
                <span class="k">if</span> <span class="n">pre</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">block</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Handle</span><span class="p">)</span> <span class="k">else</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">b</span><span class="p">)]</span> <span class="c1"># applyCl</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">block</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Handle</span><span class="p">)</span> <span class="k">else</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="c1"># applyCl</span>
            <span class="k">else</span><span class="p">:</span>                                                                <span class="c1"># applyCl</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># why do this? Because of a pretty obscure bug related to the reference counting mechanism I have here # applyCl</span>
                <span class="c1"># in preprocessF(), it returns [meats, Python references to (potential) Handles] # applyCl</span>
                <span class="c1"># I have to do this in order to keep the Handles alive. After resolveF(), everything is settled, so # applyCl</span>
                <span class="c1"># old Handles can safely be deleted                              # applyCl</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">block</span><span class="p">()]</span> <span class="k">if</span> <span class="n">pre</span> <span class="k">else</span> <span class="n">e</span><span class="o">.</span><span class="n">block</span><span class="p">()</span> <span class="c1"># don&#39;t resolve to this node, but still block execution until that object is resolvable # applyCl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preprocessF</span> <span class="o">=</span> <span class="n">preprocessF</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolveF</span> <span class="o">=</span> <span class="n">resolveF</span><span class="p">;</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">preprocessF</span> <span class="o">=</span> <span class="n">preprocessF</span><span class="p">;</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">resolveF</span> <span class="o">=</span> <span class="n">resolveF</span> <span class="c1"># references for lprun so that I can benchmark these 2 functions # applyCl</span></div>
<div class="viewcode-block" id="applyCl.installSo"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.installSo">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">installSo</span><span class="p">(</span><span class="n">fn</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">force</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>                                     <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Installs dynamic library (.so file) to all nodes.</span>

<span class="sd">:param fn: file name of the shared library</span>
<span class="sd">:param force: force reinstall even if the library is already on the remote node&quot;&quot;&quot;</span> <span class="c1"># applyCl</span>
        <span class="n">basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>                                          <span class="c1"># applyCl</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">force</span> <span class="ow">and</span> <span class="n">basename</span> <span class="ow">in</span> <span class="n">_applyCl_soCache</span><span class="p">:</span> <span class="k">return</span>                    <span class="c1"># applyCl</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Installing dynamic library to all nodes... &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">);</span> <span class="n">_applyCl_soCache</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">basename</span><span class="p">);</span> <span class="n">contents</span> <span class="o">=</span> <span class="n">cli</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="c1"># applyCl</span>
        <span class="kc">None</span> <span class="o">|</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">aS</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">contents</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">file</span><span class="p">(</span><span class="n">basename</span><span class="p">))</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">ignore</span><span class="p">();</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done&quot;</span><span class="p">)</span> <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">):</span>                                                       <span class="c1"># applyCl</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">;</span> <span class="n">bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bs</span><span class="p">;</span> <span class="n">ogF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ogF</span><span class="p">;</span> <span class="n">preprocessF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocessF</span><span class="p">;</span> <span class="n">resolveF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolveF</span> <span class="c1"># applyCl</span>
        <span class="k">if</span> <span class="n">bs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">it</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">batched</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="o">|</span> <span class="n">applyCl</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">|</span> <span class="n">apply</span><span class="p">(</span><span class="n">ogF</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">aS</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefetch</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">joinStreams</span><span class="p">()</span> <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>                                                             <span class="c1"># applyCl</span>
            <span class="n">futures</span> <span class="o">=</span> <span class="n">deque</span><span class="p">();</span> <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cpus</span><span class="p">;</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">applyCl</span><span class="o">.</span><span class="n">cpuLimit</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span> <span class="c1"># applyCl</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefetch</span><span class="p">,</span> <span class="p">(</span><span class="n">limit</span><span class="o">-</span><span class="n">_cpuUsed</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="o">//</span><span class="n">n</span><span class="p">)),</span> <span class="n">it</span><span class="p">):</span> <span class="c1"># try to anticipate how much resources can be consumed ahead of time and only schedule that much, to prevent deadlocks when multiple applyCl() is called, but their parent process has not consumed the yield statement, so the cpu count doesn&#39;t get decremented # applyCl</span>
                <span class="k">while</span> <span class="n">_cpuUsed</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="c1"># this is a very rudimentary lock. Doesn&#39;t have to be accurate though, and Python&#39;s GIL ensure atomic-ness # applyCl</span>
                <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">preprocessF</span><span class="p">(</span><span class="n">e</span><span class="p">));</span> <span class="n">_cpuUsed</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="n">n</span>              <span class="c1"># applyCl</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span> <span class="k">yield</span> <span class="n">resolveF</span><span class="p">(</span><span class="n">futures</span><span class="o">.</span><span class="n">popleft</span><span class="p">());</span> <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">preprocessF</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="c1"># free and allocate cpu slot immediately, so no while loop necessary # applyCl</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">:</span> <span class="n">res</span> <span class="o">=</span> <span class="n">resolveF</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="n">_cpuUsed</span><span class="o">.</span><span class="n">value</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span> <span class="k">yield</span> <span class="n">res</span>  <span class="c1"># applyCl</span>
        <span class="n">applyCl</span><span class="o">.</span><span class="n">rorGen</span> <span class="o">=</span> <span class="n">gen</span>                                                     <span class="c1"># applyCl</span>
        <span class="k">return</span> <span class="n">gen</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>                                                           <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.__invert__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.__invert__">[docs]</a>    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                                                        <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expands the arguments out, just like :class:`apply`.</span>
<span class="sd">Example::</span>

<span class="sd">    # returns [20, 20, 18, 14, 8, 0, -10, -22, -36, -52]</span>
<span class="sd">    [range(10), range(20, 30)] | transpose() | ~applyCl(lambda x, y: y-x**2) | deref()&quot;&quot;&quot;</span> <span class="c1"># applyCl</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copyCtx</span><span class="p">();</span> <span class="k">return</span> <span class="n">applyCl</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="o">*</span><span class="n">rest</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.nodeIds"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.nodeIds">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">nodeIds</span><span class="p">(</span><span class="n">includeSelf</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>                                  <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of all node ids in the current cluster.</span>
<span class="sd">Example::</span>

<span class="sd">    applyCl.nodeIds() # returns something like [&#39;7bb387b2920694abe9f7d2a2ed939b6d31843faf91d174d0221e871d&#39;, &#39;1051dafd2b0dac13561c46fe052f561400592f0723df2cd746a41068&#39;]</span>

<span class="sd">If you want to get nodes&#39; metadata, then just use ray&#39;s builtin function ``ray.nodes()``</span>

<span class="sd">:param includeSelf: whether to include node id of the current process or not&quot;&quot;&quot;</span>  <span class="c1"># applyCl</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">filt</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;Alive&quot;</span><span class="p">])</span> <span class="o">|</span> <span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;NodeID&quot;</span><span class="p">])</span> <span class="o">|</span> <span class="n">aS</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> <span class="c1"># applyCl</span>
        <span class="k">if</span> <span class="n">includeSelf</span><span class="p">:</span> <span class="k">return</span> <span class="n">res</span>                                               <span class="c1"># applyCl</span>
        <span class="n">res</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">applyCl</span><span class="o">.</span><span class="n">nodeId</span><span class="p">());</span> <span class="k">return</span> <span class="n">res</span>                                 <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.nodeId"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.nodeId">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="nd">@lru_cache</span>                                                                   <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">nodeId</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>                                                         <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns current node id&quot;&quot;&quot;</span>                                            <span class="c1"># applyCl</span>
        <span class="k">return</span> <span class="n">ray</span><span class="o">.</span><span class="n">runtime_context</span><span class="o">.</span><span class="n">get_runtime_context</span><span class="p">()</span><span class="o">.</span><span class="n">get_node_id</span><span class="p">()</span>           <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.meta"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.meta">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">meta</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>                                                        <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Grabs the metadata object for the current node&quot;&quot;&quot;</span>                     <span class="c1"># applyCl</span>
        <span class="k">return</span> <span class="n">ray</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">filt</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;NodeID&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">nodeId</span><span class="p">())</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.cpu"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.cpu">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">cpu</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>                                                            <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Grabs the number of cpus available on this node&quot;&quot;&quot;</span>                    <span class="c1"># applyCl</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">applyCl</span><span class="o">.</span><span class="n">meta</span><span class="p">()[</span><span class="s2">&quot;Resources&quot;</span><span class="p">][</span><span class="s2">&quot;CPU&quot;</span><span class="p">])</span>                           <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.aS"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.aS">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">aS</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>                                                         <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Executes function f once for all node ids that are piped in.</span>
<span class="sd">Example::</span>

<span class="sd">    # returns [[&#39;1051da...&#39;, [&#39;Desktop&#39;, &#39;Downloads&#39;]], [&#39;7bb387...&#39;, [&#39;Pictures&#39;, &#39;Music&#39;]]]</span>
<span class="sd">    applyCl.nodeIds() | applyCl.aS(lambda: None | cmd(&quot;ls ~&quot;) | deref()) | deref()</span>
<span class="sd">    # same as above, demonstrating passing in a list of nodeIds</span>
<span class="sd">    [&quot;1051da...&quot;, &quot;7bb387...&quot;] | applyCl.aS(lambda: None | cmd(&quot;ls ~&quot;) | deref()) | deref()</span>
<span class="sd">    # same as above, demonstrating passing in &quot;None&quot; for all nodeIds in the cluster</span>
<span class="sd">    None | applyCl.aS(lambda: None | cmd(&quot;ls ~&quot;) | deref()) | deref()</span>

<span class="sd">If you want to execute f for all nodes, you can pass in None instead.</span>

<span class="sd">As a reminder, this kinda follows the same logic as the popular cli :class:`aS`, where</span>
<span class="sd">f is executed once, hence the name &quot;apply Single&quot;. Here, the meaning of &quot;single&quot; is</span>
<span class="sd">different. It just means execute once for each node ids. If you want to quickly execute</span>
<span class="sd">a function on a single node, without all the fuss, there&#39;s this short form that you can follow::</span>

<span class="sd">    # returns [&#39;Desktop&#39;, &#39;Downloads&#39;], demonstrating that you can also pass in a single node id</span>
<span class="sd">    &quot;1051da...&quot; | applyCl.aS(lambda: None | cmd(&quot;ls ~&quot;) | deref()) | deref()</span>

<span class="sd">:param f: main function to execute in each node. Not supposed to accept any arguments</span>
<span class="sd">:param kwargs: keyword arguments for the main :class:`applyCl` function&quot;&quot;&quot;</span>       <span class="c1"># applyCl</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">fastF</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="n">final</span> <span class="o">=</span> <span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="n">applyCl</span><span class="p">(</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">f</span><span class="p">(),</span> <span class="n">pre</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>                                                           <span class="c1"># applyCl</span>
            <span class="n">shortform</span> <span class="o">=</span> <span class="kc">False</span>                                                    <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="n">it</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">it</span> <span class="o">=</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">nodeIds</span><span class="p">()</span>                                <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span> <span class="n">it</span> <span class="o">=</span> <span class="p">[</span><span class="n">it</span><span class="p">];</span> <span class="n">shortform</span> <span class="o">=</span> <span class="kc">True</span>                  <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="n">it</span> <span class="o">|</span> <span class="o">~</span><span class="n">cli</span><span class="o">.</span><span class="n">inSet</span><span class="p">(</span><span class="n">_nodeIdsCache</span><span class="p">())</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># caching nodeIds(), because that takes a surprising amount of time # applyCl</span>
                <span class="n">_nodeIdsCache</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">nodeIds</span><span class="p">();</span> <span class="n">outliers</span> <span class="o">=</span> <span class="n">it</span> <span class="o">|</span> <span class="o">~</span><span class="n">cli</span><span class="o">.</span><span class="n">inSet</span><span class="p">(</span><span class="n">_nodeIdsCache</span><span class="p">())</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">()</span> <span class="c1"># applyCl</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outliers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;These nodes cannot be found: </span><span class="si">{</span><span class="n">outliers</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># applyCl</span>
            <span class="k">return</span> <span class="n">it</span> <span class="o">|</span> <span class="n">final</span> <span class="o">|</span> <span class="p">((</span><span class="n">cli</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">item</span><span class="p">())</span> <span class="k">if</span> <span class="n">shortform</span> <span class="k">else</span> <span class="n">cli</span><span class="o">.</span><span class="n">iden</span><span class="p">())</span> <span class="c1"># applyCl</span>
        <span class="k">return</span> <span class="n">aS</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>                                                         <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.cmd"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.cmd">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">cmd</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">sudo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nodeIds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>                          <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience function to execute shell command on all nodes.</span>
<span class="sd">Example::</span>

<span class="sd">    applyCl.cmd(&quot;mkdir -p /some/folder&quot;)</span>

<span class="sd">It returns [[nodeid1, output1], [nodeid2, output2]]. If you need more flexibility,</span>
<span class="sd">fall back to :meth:`applyCl.aS`</span>

<span class="sd">:param s: shell command to execute</span>
<span class="sd">:param sudo: if True, will execute the command with sudo privileges. Will ask for password</span>
<span class="sd">    and then cache it internally for 5 minutes</span>
<span class="sd">:param kwargs: keyword arguments to pass to :class:`applyCl`&quot;&quot;&quot;</span>                  <span class="c1"># applyCl</span>
        <span class="k">global</span> <span class="n">_password</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">getpass</span>                                         <span class="c1"># applyCl</span>
        <span class="k">if</span> <span class="n">sudo</span><span class="p">:</span>                                                                 <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="n">_password</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>                                              <span class="c1"># applyCl</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter password:&quot;</span><span class="p">);</span> <span class="n">_password</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">getpass</span><span class="o">.</span><span class="n">getpass</span><span class="p">(</span><span class="n">prompt</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="c1"># applyCl</span>
            <span class="k">return</span>   <span class="n">nodeIds</span> <span class="o">|</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">aS</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">_password</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">cmd</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sudo -S </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">()</span> <span class="c1"># applyCl</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">nodeIds</span> <span class="o">|</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">aS</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span>        <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">cmd</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>              <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">()</span> <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.lookup"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.lookup">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">lookup</span><span class="p">():</span>                                                                <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tries to lookup a particular file to see on which node it&#39;s at.</span>
<span class="sd">Example::</span>

<span class="sd">    # returns [[nodeId, &quot;something.txt&quot;], [nodeId, &quot;abc.jpg&quot;]]</span>
<span class="sd">    [&quot;something.txt&quot;, &quot;abc.jpg&quot;] | applyCl.lookup()</span>
<span class="sd">    # returns [nodeId, &quot;something.txt&quot;]</span>
<span class="sd">    &quot;something.txt&quot; | applyCl.lookup()</span>

<span class="sd">Files that don&#39;t exist won&#39;t be included in the result, and files that</span>
<span class="sd">exist on multiple nodes will be returned multiple times. The output format</span>
<span class="sd">is such that I can pipe it into applyCl(..., pre=True) and have it execute</span>
<span class="sd">some function that I want. This is pretty much just a convenience function.&quot;&quot;&quot;</span>   <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">fns</span><span class="p">):</span>                                                          <span class="c1"># applyCl</span>
            <span class="n">fns</span> <span class="o">=</span> <span class="n">fns</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">();</span> <span class="n">single</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fns</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>               <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="n">single</span><span class="p">:</span> <span class="n">fns</span> <span class="o">=</span> <span class="p">[</span><span class="n">fns</span><span class="p">]</span>                                               <span class="c1"># applyCl</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">aS</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">fns</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">iden</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">)</span> <span class="o">|</span> <span class="n">apply</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">))</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">filt</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">())</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">ungroup</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">()</span> <span class="c1"># applyCl</span>
            <span class="k">return</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">single</span> <span class="k">else</span> <span class="n">ans</span>                                     <span class="c1"># applyCl</span>
        <span class="k">return</span> <span class="n">cli</span><span class="o">.</span><span class="n">aS</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>                                                     <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.replicateFile"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.replicateFile">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">replicateFile</span><span class="p">(</span><span class="n">fn</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">nodeIds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>                                     <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replicates a specific file in the current node to all the other nodes.</span>
<span class="sd">Example::</span>

<span class="sd">    applyCl.replicateFile(&quot;~/cron.log&quot;)</span>

<span class="sd">Internally, this will read chunks of 100kB of the specified file and dump it</span>
<span class="sd">incrementally to all other nodes, which has implications on performance. To</span>
<span class="sd">increase or decrease it, check out :class:`~k1lib.cli.inp.cat`. This also means</span>
<span class="sd">you can replicate arbitrarily large files around as long as you have the disk</span>
<span class="sd">space for it, while ram size doesn&#39;t really matter</span>

<span class="sd">Please note that this operation is not symmetric. Unlike :meth:`balanceFile` and</span>
<span class="sd">:meth:`balanceFolder`, in which they can be invoke on any node and it&#39;ll roughly</span>
<span class="sd">do the same thing (rebalances everything out), this operation can do totally</span>
<span class="sd">different things depending on which node you run it on. Let&#39;s say the file exists</span>
<span class="sd">on nodes A and B, but not on nodes C and D. If you run this function on either</span>
<span class="sd">node A or B, it will replicate the file to C and D. However, if you run this</span>
<span class="sd">function on node C or D, it will instead throw an error since the file doesn&#39;t</span>
<span class="sd">exist.</span>

<span class="sd">:param fn: file name&quot;&quot;&quot;</span>                                                          <span class="c1"># applyCl</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span> <span class="n">dirname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>               <span class="c1"># applyCl</span>
        <span class="c1"># checking if there&#39;s an existing file already. If there is, then don&#39;t try to copy data to that node # applyCl</span>
        <span class="k">if</span> <span class="n">nodeIds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">canSize</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span> <span class="n">nodeIds</span> <span class="o">=</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">aS</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">filt</span><span class="p">(</span><span class="n">cli</span><span class="o">.</span><span class="n">op</span><span class="p">()</span> <span class="o">!=</span> <span class="n">canSize</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">()</span> <span class="c1"># applyCl</span>
        <span class="n">nodeIds</span> <span class="o">=</span> <span class="n">nodeIds</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">wrapList</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">()</span>                   <span class="c1"># applyCl</span>
        <span class="n">nodeIds</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">|</span> <span class="n">applyCl</span><span class="p">(</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">cmd</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mkdir -p </span><span class="si">{</span><span class="n">dirname</span><span class="si">}</span><span class="s2">; rm -rf </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">(),</span> <span class="n">pre</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">()</span> <span class="c1"># applyCl</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">cli</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> <span class="n">nodeIds</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">|</span> <span class="n">applyCl</span><span class="p">(</span><span class="k">lambda</span> <span class="n">chunk</span><span class="p">:</span> <span class="n">chunk</span> <span class="o">&gt;&gt;</span> <span class="n">cli</span><span class="o">.</span><span class="n">file</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">(),</span> <span class="n">pre</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">()</span> <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.balanceFile"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.balanceFile">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">balanceFile</span><span class="p">(</span><span class="n">fn</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">nAs</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nBs</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunkSize</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">100_000_000</span><span class="p">):</span> <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Splits a specified file in node nAs and dumps other parts</span>
<span class="sd">to nodes nBs. Example::</span>

<span class="sd">    applyCl.balanceFile(&quot;~/cron.log&quot;)</span>

<span class="sd">This will split the big files up into multiple segments (1 for each node). Then</span>
<span class="sd">for each segment, it will read through it chunk by chunk into memory, and then</span>
<span class="sd">deposits it into the respective nodes. Finally, it truncates the original files</span>
<span class="sd">down to its segment boundary.</span>

<span class="sd">The main goal of this is so that you can analyze a single big (say 200GB) file</span>
<span class="sd">quickly. If that file is on a single node, then it will take forever, even with</span>
<span class="sd">:class:`applyMp`. So splitting things up on multiple nodes will make analyzing</span>
<span class="sd">it a lot faster.</span>

<span class="sd">There&#39;s also the function :meth:`balanceFolder`, which has the opposite problem of</span>
<span class="sd">having lots of small (say 100MB) files. So it will try to move files around (keeping</span>
<span class="sd">them intact in the meantime) to different nodes so that the folder size ratio is</span>
<span class="sd">roughly proportional to the cpu count.</span>

<span class="sd">The exact split rule depends on the number of CPUs of each node. Best to see an</span>
<span class="sd">example::</span>

<span class="sd">    Command:         applyCl.balanceFile(&quot;~/cron.log&quot;)</span>
<span class="sd">    Verbose command: applyCl.balanceFile(&quot;~/cron.log&quot;, [&quot;1&quot;], [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;])</span>
<span class="sd">    ----------- Before -----------</span>
<span class="sd">    Node:      1  2  3  4 5</span>
<span class="sd">    Cpu:       8  12 16 8 8</span>
<span class="sd">    Size (GB): 52 0  0  0 0</span>
<span class="sd">    ----------- After  -----------</span>
<span class="sd">    Node:      1  2  3  4 5</span>
<span class="sd">    Cpu:       8  12 16 8 8</span>
<span class="sd">    Size (GB): 8  12 16 8 8</span>

<span class="sd">This also works if you have files on existing nodes already, and are upgrading the</span>
<span class="sd">cluster::</span>

<span class="sd">    Command:         applyCl.balanceFile(&quot;~/cron.log&quot;)</span>
<span class="sd">    Verbose command: applyCl.balanceFile(&quot;~/cron.log&quot;, [&quot;1&quot;, &quot;5&quot;], [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;])</span>
<span class="sd">    ----------- Before -----------</span>
<span class="sd">    Node:      1  2  3  4  5</span>
<span class="sd">    Cpu:       8  12 16 8  8</span>
<span class="sd">    Size (GB): 26 0  0  26 0</span>
<span class="sd">    ----------- After  -----------</span>
<span class="sd">    Node:      1  2  3  4  5</span>
<span class="sd">    Cpu:       8  12 16 8  8</span>
<span class="sd">    Size (GB): 8  12 16 8  8</span>

<span class="sd">If you want to move files out of a node when decommissioning them, you can do</span>
<span class="sd">something like this::</span>

<span class="sd">    Command:         applyCl.decommission(&quot;~/cron.log&quot;, [&quot;3&quot;, &quot;4&quot;])</span>
<span class="sd">    Verbose command: applyCl.balanceFile(&quot;~/cron.log&quot;, [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;], [&quot;1&quot;, &quot;2&quot;, &quot;5&quot;])</span>
<span class="sd">    ----------- Before -----------</span>
<span class="sd">    Node:      1  2  3  4 5</span>
<span class="sd">    Cpu:       8  12 16 8 8</span>
<span class="sd">    Size (GB): 8  12 16 8 8</span>
<span class="sd">    ----------- After  -----------</span>
<span class="sd">    Node:      1  2  3  4 5</span>
<span class="sd">    Cpu:       8  12 16 8 8</span>
<span class="sd">    Size (GB): 15 22 0  0 15</span>

<span class="sd">Remember that the node ids &quot;1&quot;, etc. is for illustrative purposes only. You should get</span>
<span class="sd">real node ids from :meth:`nodeIds`.</span>

<span class="sd">Why is the file size proportional to the number of cores on each node? Well, if</span>
<span class="sd">you have more cores, you should be able to process more, so as to make everything</span>
<span class="sd">balanced, right?</span>

<span class="sd">Again, this means that you can split arbitrarily large files as long as you have</span>
<span class="sd">the disk space for it, ram size is not a concern. How does this perform? Not</span>
<span class="sd">the best in the world if you don&#39;t have a lot of nodes. With sata 3 ssds, 750MB/s</span>
<span class="sd">ethernet, I got transfer speeds of roughly 100MB/s. This should increase as you</span>
<span class="sd">have more nodes based on the code structure, but I haven&#39;t tested it yet. Can</span>
<span class="sd">it be faster? Definitely. Am I willing to spend time optimizing it? No.</span>

<span class="sd">:param fn: file name</span>
<span class="sd">:param nAs: node ids that currently stores the file. If not specified, try to detect</span>
<span class="sd">    what nodes the file exists in</span>
<span class="sd">:param nBs: node ids that will store the file after balancing everything out. If not</span>
<span class="sd">    specified, will take all available nodes</span>
<span class="sd">:param rS: :class:`~k1lib.cli.inp.refineSeek` instance, if you need more fine-grained</span>
<span class="sd">    control over section boundaries so as to not make everything corrupted</span>
<span class="sd">:param chunkSize: see :meth:`balanceFolder`</span>
<span class="sd">&quot;&quot;&quot;</span>                                                                              <span class="c1"># applyCl</span>
        <span class="kn">from</span> <span class="nn">k1lib.cli._applyCl</span> <span class="kn">import</span> <span class="n">balanceFile</span>                               <span class="c1"># applyCl</span>
        <span class="k">with</span> <span class="n">settings</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="n">chunkSize</span><span class="o">=</span><span class="n">chunkSize</span><span class="p">):</span> <span class="n">balanceFile</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">nAs</span><span class="p">,</span> <span class="n">nBs</span><span class="p">,</span> <span class="n">rS</span><span class="p">)</span> <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.decommissionFile"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.decommissionFile">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">decommissionFile</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">nAs</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">rS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunkSize</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">100_000_000</span><span class="p">):</span> <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience function for :meth:`balanceFile`. See docs over there.&quot;&quot;&quot;</span> <span class="c1"># applyCl</span>
        <span class="kn">from</span> <span class="nn">k1lib.cli._applyCl</span> <span class="kn">import</span> <span class="n">balanceFile</span>                               <span class="c1"># applyCl</span>
        <span class="k">with</span> <span class="n">settings</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="n">chunkSize</span><span class="o">=</span><span class="n">chunkSize</span><span class="p">):</span> <span class="n">balanceFile</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">nodeIds</span><span class="p">()</span> <span class="o">|</span> <span class="o">~</span><span class="n">cli</span><span class="o">.</span><span class="n">inSet</span><span class="p">(</span><span class="n">nAs</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">(),</span> <span class="n">rS</span><span class="p">)</span> <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.cat"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.cat">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">cat</span><span class="p">(</span><span class="n">fn</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span><span class="n">Callable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nodeIds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">pre</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">multiplier</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">includeId</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">resolve</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads a file distributedly, does some operation on them, collects and</span>
<span class="sd">returns all of the data together. Example::</span>

<span class="sd">    fn = &quot;~/repos/labs/k1lib/k1lib/cli/test/applyCl.cat.data&quot;</span>
<span class="sd">    (&quot;0123456789&quot;*5 + &quot;\\n&quot;) * 1000 | file(fn)</span>
<span class="sd">    applyCl.splitFile(fn)</span>
<span class="sd">    applyCl.cat(fn, shape(0), keepNodeIds=True) | deref()</span>

<span class="sd">That returns something like this (for a 2-node cluster, with 2 (node A) and 4 (node B) cpus respectively)::</span>

<span class="sd">    [[&#39;7bb387b2920694abe9f7d2a2ed939b6d31843faf91d174d0221e871d&#39;, 167],</span>
<span class="sd">     [&#39;7bb387b2920694abe9f7d2a2ed939b6d31843faf91d174d0221e871d&#39;, 167],</span>
<span class="sd">     [&#39;1051dafd2b0dac13561c46fe052f561400592f0723df2cd746a41068&#39;, 166],</span>
<span class="sd">     [&#39;1051dafd2b0dac13561c46fe052f561400592f0723df2cd746a41068&#39;, 167],</span>
<span class="sd">     [&#39;1051dafd2b0dac13561c46fe052f561400592f0723df2cd746a41068&#39;, 166],</span>
<span class="sd">     [&#39;1051dafd2b0dac13561c46fe052f561400592f0723df2cd746a41068&#39;, 167]]</span>

<span class="sd">Here, we&#39;re creating an initial file with 1000 lines. Then we&#39;ll split it up into</span>
<span class="sd">2 fragments: 334 lines and 667 lines and store them on the respective nodes. Then,</span>
<span class="sd">on node A, we&#39;ll split the file up into 2 parts, each with 167 lines. On node B,</span>
<span class="sd">we&#39;ll split the file up into 4 parts, each with around 166 lines. Then we&#39;ll</span>
<span class="sd">schedule 6 processes total, each dealing with 166 lines. After all of that, results</span>
<span class="sd">are collected together and returned.</span>

<span class="sd">If you want to distinguish between different processes inside f, for example you</span>
<span class="sd">want to write results into different files, you can do something like this::</span>

<span class="sd">    dir_ = &quot;~/repos/labs/k1lib/k1lib/cli/test&quot;</span>
<span class="sd">    fn = f&quot;{dir_}/applyCl.cat.data&quot;</span>
<span class="sd">    applyCl.cmd(f&quot;rm -r {dir_}/applyCl&quot;)    # clear out old folders</span>
<span class="sd">    applyCl.cmd(f&quot;mkdir -p {dir_}/applyCl&quot;) # creating folders</span>
<span class="sd">    # do processing on fn distributedly, then dump results into multiple files</span>
<span class="sd">    applyCl.cat(fn, ~aS(lambda idx, lines: lines | shape(0) | aS(dill.dumps) | file(f&quot;{dir_}/applyCl/{idx}.pth&quot;)), includeId=True) | deref()</span>
<span class="sd">    # reading all files and summing them together</span>
<span class="sd">    None | applyCl.aS(lambda: ls(f&quot;{dir_}/applyCl&quot;)) | ungroup() | applyCl(cat(text=False) | aS(dill.loads), pre=True) | cut(1) | toSum()</span>

<span class="sd">.. admonition:: Simple mode</span>

<span class="sd">    There&#39;s also another mode that&#39;s activated whenever f is not specified that feels</span>
<span class="sd">    more like vanilla :class:`~inp.cat`. Say you have a file on a specific node::</span>

<span class="sd">        nodeId = &quot;7bb387b2920694abe9f7d2a2ed939b6d31843faf91d174d0221e871d&quot;</span>
<span class="sd">        fn = &quot;~/ssd2/randomFile.txt&quot;</span>

<span class="sd">        # -------------- file is on current node --------------</span>
<span class="sd">        cat(fn) # returns iterator of lines inside the file</span>
<span class="sd">        fn | cat() # same thing as above</span>
<span class="sd">        # -------------- file is on remote node --------------</span>
<span class="sd">        [nodeId, fn] | applyCl.cat() # returns iterator of lines of the file</span>
<span class="sd">        applyCl.cat([nodeId, fn]) # same thing</span>
<span class="sd">        nodeId | applyCl.cat(fn) # also same thing</span>

<span class="sd">    So yeah, there&#39;re lots of ways to just simply read a file on a remote node. Is</span>
<span class="sd">    it too much? Probably, but good thing is that you can pick any that&#39;s intuitive</span>
<span class="sd">    for you. Note that this mode is just for convenience only, for when you want to do</span>
<span class="sd">    exploratory analysis on a single remote file. To be efficient at bulk processing,</span>
<span class="sd">    use the normal mode instead.</span>

<span class="sd">:param fn: file name</span>
<span class="sd">:param f: function to execute in every process</span>
<span class="sd">:param nodeIds: only read file from these nodes</span>
<span class="sd">:param timeout: kills the processes if it takes longer than this amount of seconds</span>
<span class="sd">:param pre: &quot;preserve&quot; mode, just like in :class:`applyCl`. Whether to keep the node id column or not</span>
<span class="sd">:param multiplier: by default, each node will spawn as many process as there</span>
<span class="sd">    are cpus. Sometimes you want to spawn more process, change this to a higher number</span>
<span class="sd">:param includeId: includes a unique id for this process (just normal integers from 0 to n)</span>
<span class="sd">:param resolve: whether to resolve the remote objects or not</span>
<span class="sd">&quot;&quot;&quot;</span>                                                                              <span class="c1"># applyCl</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>                  <span class="c1"># applyCl</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># simple case                                              # applyCl</span>
            <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">nodeId_fn</span><span class="p">:</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>                                <span class="c1"># applyCl</span>
                <span class="n">nodeId</span><span class="p">,</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">nodeId_fn</span><span class="p">;</span> <span class="n">seeks</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodeId</span><span class="p">]</span> <span class="o">|</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">aS</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">fn</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">splitSeek</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">/</span><span class="n">settings</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">chunkSize</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">()</span> <span class="c1"># applyCl</span>
                <span class="n">inter</span> <span class="o">=</span> <span class="n">seeks</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">window</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">apply</span><span class="p">(</span><span class="n">cli</span><span class="o">.</span><span class="n">wrapList</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nodeId</span><span class="p">))</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">()</span> <span class="c1"># applyCl</span>
                <span class="k">return</span> <span class="n">inter</span> <span class="o">|</span> <span class="o">~</span><span class="n">applyCl</span><span class="p">(</span><span class="k">lambda</span> <span class="n">sB</span><span class="p">,</span> <span class="n">eB</span><span class="p">:</span> <span class="n">cli</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">sB</span><span class="o">=</span><span class="n">sB</span><span class="p">,</span><span class="n">eB</span><span class="o">=</span><span class="n">eB</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">(),</span> <span class="n">pre</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">joinStreams</span><span class="p">()</span> <span class="c1"># applyCl</span>
                <span class="c1"># return [nodeId_fn] | applyCl(cat() | deref(), pre=True) | cut(1) | item() # direct, no chunking method # applyCl</span>
            <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">aS</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span> <span class="c1"># [nodeId, fn] | applyCl.cat()       # applyCl</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span> <span class="k">return</span> <span class="n">aS</span><span class="p">(</span><span class="k">lambda</span> <span class="n">nodeId</span><span class="p">:</span> <span class="n">inner</span><span class="p">([</span><span class="n">nodeId</span><span class="p">,</span> <span class="n">fn</span><span class="p">]))</span> <span class="c1"># nodeId | applyCl.cat() # applyCl</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">inner</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="c1"># applyCl.cat([nodeId, fn])                   # applyCl</span>
        <span class="n">nodeIds</span> <span class="o">=</span> <span class="n">nodeIds</span> <span class="ow">or</span> <span class="p">(</span><span class="n">applyCl</span><span class="o">.</span><span class="n">nodeIds</span><span class="p">()</span> <span class="o">|</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">aS</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fn</span><span class="p">))</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">filt</span><span class="p">(</span><span class="n">cli</span><span class="o">.</span><span class="n">op</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">())</span> <span class="c1"># applyCl</span>
        <span class="n">checkpoints</span> <span class="o">=</span> <span class="n">nodeIds</span> <span class="o">|</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">aS</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">fn</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">splitSeek</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">applyCl</span><span class="o">.</span><span class="n">meta</span><span class="p">()[</span><span class="s2">&quot;Resources&quot;</span><span class="p">][</span><span class="s2">&quot;CPU&quot;</span><span class="p">]</span><span class="o">*</span><span class="n">multiplier</span><span class="p">))</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">window</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">())</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">ungroup</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">insertIdColumn</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="p">,[</span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]])</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">()</span> <span class="c1"># applyCl</span>
        <span class="k">return</span> <span class="n">checkpoints</span> <span class="o">|</span> <span class="n">applyCl</span><span class="p">(</span><span class="o">~</span><span class="n">aS</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">idx</span><span class="p">:</span> <span class="n">cli</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">sB</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">eB</span><span class="o">=</span><span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">cli</span><span class="o">.</span><span class="n">wrapList</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="k">if</span> <span class="n">includeId</span> <span class="k">else</span> <span class="n">cli</span><span class="o">.</span><span class="n">iden</span><span class="p">())</span> <span class="o">|</span> <span class="n">f</span><span class="p">),</span> <span class="n">pre</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">,</span> <span class="n">num_cpus</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">resolve</span><span class="o">=</span><span class="n">resolve</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cli</span><span class="o">.</span><span class="n">iden</span><span class="p">()</span> <span class="k">if</span> <span class="n">pre</span> <span class="k">else</span> <span class="n">cli</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.replicateFolder"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.replicateFolder">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">replicateFolder</span><span class="p">(</span><span class="n">folder</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">nodeIds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>                               <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replicates a specific folder in the current node to all the other nodes.</span>
<span class="sd">Example::</span>

<span class="sd">    applyCl.replicateFolder(&quot;~/ssd2/data/owl&quot;)</span>

<span class="sd">This just list out all files recursively in the specified folder, then replicate each file using :meth:`replicateFile`&quot;&quot;&quot;</span> <span class="c1"># applyCl</span>
        <span class="n">applyCl</span><span class="o">.</span><span class="n">getFilesInFolder</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span> <span class="o">|</span> <span class="n">applyCl</span><span class="p">(</span><span class="k">lambda</span> <span class="n">fn</span><span class="p">:</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">replicateFile</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">nodeIds</span><span class="p">),</span> <span class="n">num_cpus</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">deref</span><span class="p">()</span> <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.balanceFolder"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.balanceFolder">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">balanceFolder</span><span class="p">(</span><span class="n">folder</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">maxSteps</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">audit</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bs</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">chunkSize</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">100_000_000</span><span class="p">):</span> <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Balances all files within a folder across all nodes.</span>
<span class="sd">Example::</span>

<span class="sd">    # make the chunk size huge so that transfers become faster</span>
<span class="sd">    settings.cli.cat.chunkSize = 100_000_000</span>
<span class="sd">    base = &quot;~/repos/labs/k1lib/k1lib/cli/test/applyCl.balance&quot;</span>
<span class="sd">    # deletes old structures and making test folder</span>
<span class="sd">    applyCl.cmd(f&quot;rm -r {base}&quot;); applyCl.cmd(f&quot;mkdir -p {base}&quot;)</span>
<span class="sd">    # creates 20 files of different sizes and dump it in the base folder of the current node</span>
<span class="sd">    torch.linspace(1e4, 1e5, 20).int() | apply(lambda x: &quot;x&quot;*x) | insertIdColumn() | ~apply(lambda idx, contents: contents | file(f&quot;{base}/{idx}.txt&quot;)) | deref();</span>
<span class="sd">    # transfers files between nodes such that the total folder size is proportional to the number of cpus across nodes</span>
<span class="sd">    applyCl.balanceFolder(base)</span>
<span class="sd">    # get folder size of all nodes</span>
<span class="sd">    None | applyCl.aS(lambda: ls(base) | apply(os.path.getsize) | toSum()) | deref()</span>

<span class="sd">    # creates 20 additional files and dump it to the current node</span>
<span class="sd">    torch.linspace(1e4, 1e5, 20).int() | apply(lambda x: &quot;x&quot;*x) | insertIdColumn() | ~apply(lambda idx, contents: contents | file(f&quot;{base}/{idx+20}.txt&quot;)) | deref();</span>
<span class="sd">    # balances the tree out again</span>
<span class="sd">    applyCl.balance(base)</span>
<span class="sd">    # get folder size of all nodes</span>
<span class="sd">    None | applyCl.aS(lambda: ls(base) | apply(os.path.getsize) | toSum()) | deref()</span>

<span class="sd">So imagine that you just downloaded 1000 files to a single node on a specific folder,</span>
<span class="sd">but you need to analyze all of them in a distributed manner. What you can do is to</span>
<span class="sd">move some files to other nodes and then do your analysis. If you want to download</span>
<span class="sd">more files, just dump it to any node (or download distributed across all nodes),</span>
<span class="sd">then rebalance the folders and do your analysis.</span>

<span class="sd">Also, internally, it splits files into multiple chunks, transfer the chunks to other</span>
<span class="sd">nodes and append to the correct files. It uses :meth:`~k1lib.cli.inp.cat` to split up</span>
<span class="sd">the file, which has settings under ``settings.cli.cat``. By default, the chunk size is</span>
<span class="sd">100k bytes, which I think is the sweet spot because :meth:`~k1lib.cli.inp.cat` also</span>
<span class="sd">supports remote file accessed from the internet and sometimes the library is used for</span>
<span class="sd">systems with very few memory. But for this use case where you already have the insane</span>
<span class="sd">hardware for this, 100kB is extremely small and will slow transfer rates to a crawl,</span>
<span class="sd">so in this function, it will be temporarily be set to the parameter ``ChunkSize``, which</span>
<span class="sd">is 100MB by default.</span>

<span class="sd">:param folder: folder to rebalance all of the files</span>
<span class="sd">:param maxSteps: what&#39;s the maximum number of file transfers? By default has no limit, so that files are transferred until</span>
<span class="sd">:param audit: if True, don&#39;t actually move files around and just return what files are going to be moved where</span>
<span class="sd">:param bs: batch size for transporting this many files at once. Increase to make it faster, but with the</span>
<span class="sd">    penalty of the progress bar not updating as frequently</span>
<span class="sd">:param chunkSize: file chunk size to split up and send to other nodes</span>
<span class="sd">&quot;&quot;&quot;</span>                                                                              <span class="c1"># applyCl</span>
        <span class="kn">from</span> <span class="nn">k1lib.cli._applyCl</span> <span class="kn">import</span> <span class="n">balanceFolder</span>                             <span class="c1"># applyCl</span>
        <span class="k">with</span> <span class="n">settings</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="n">chunkSize</span><span class="o">=</span><span class="n">chunkSize</span><span class="p">):</span> <span class="k">return</span> <span class="n">balanceFolder</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">audit</span><span class="p">,</span> <span class="n">maxSteps</span><span class="p">,</span> <span class="n">bs</span><span class="o">=</span><span class="n">bs</span><span class="p">)</span> <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.decommissionFolder"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.decommissionFolder">[docs]</a>    <span class="k">def</span> <span class="nf">decommissionFolder</span><span class="p">(</span><span class="n">folder</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">nAs</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">maxSteps</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">audit</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">3600</span><span class="p">,</span> <span class="n">bs</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">chunkSize</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">100_000_000</span><span class="p">):</span> <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like :meth:`decommissionFile`, but works for distributed folders instead.</span>

<span class="sd">:param nAs: list of node ids to migrate files away from</span>
<span class="sd">:param maxSteps: limits the total number of optimization steps. Normally don&#39;t have to specify,</span>
<span class="sd">    but just here in case it runs for too long trying to optimize the folder structure</span>
<span class="sd">:param audit: if True, just returns the file movements it&#39;s planning to do</span>
<span class="sd">:param bs: batch size for transporting this many files at once. Increase to make it faster, but with the</span>
<span class="sd">    penalty of the progress bar not updating as frequently</span>
<span class="sd">:param chunkSize: see :meth:`balanceFolder`</span>
<span class="sd">&quot;&quot;&quot;</span>                                                                              <span class="c1"># applyCl</span>
        <span class="kn">from</span> <span class="nn">k1lib.cli._applyCl</span> <span class="kn">import</span> <span class="n">decommissionFolder</span>                        <span class="c1"># applyCl</span>
        <span class="k">with</span> <span class="n">settings</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="n">chunkSize</span><span class="o">=</span><span class="n">chunkSize</span><span class="p">):</span> <span class="k">return</span> <span class="n">decommissionFolder</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">nAs</span><span class="p">,</span> <span class="n">audit</span><span class="o">=</span><span class="n">audit</span><span class="p">,</span> <span class="n">maxSteps</span><span class="o">=</span><span class="n">maxSteps</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">,</span> <span class="n">bs</span><span class="o">=</span><span class="n">bs</span><span class="p">)</span> <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.pruneFolder"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.pruneFolder">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">pruneFolder</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>                                                     <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes empty directories recursively from a root folder.&quot;&quot;&quot;</span>          <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>                                                       <span class="c1"># applyCl</span>
            <span class="n">folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>                                  <span class="c1"># applyCl</span>
            <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="o">=</span> <span class="n">folder</span> <span class="o">|</span> <span class="n">ls</span><span class="p">()</span> <span class="o">|</span> <span class="n">filt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="o">|</span> <span class="n">deref</span><span class="p">()</span>  <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span>                                            <span class="c1"># applyCl</span>
            <span class="n">dirs</span> <span class="o">|</span> <span class="n">apply</span><span class="p">(</span><span class="n">pruneFolder</span><span class="p">)</span> <span class="o">|</span> <span class="n">ignore</span><span class="p">()</span>                                 <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="n">folder</span> <span class="o">|</span> <span class="n">ls</span><span class="p">()</span> <span class="o">|</span> <span class="n">shape</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">cmd</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;rm -rf </span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">ignore</span><span class="p">()</span> <span class="c1"># applyCl</span>
        <span class="kc">None</span> <span class="o">|</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">aS</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">inner</span><span class="p">(</span><span class="n">folder</span><span class="p">))</span> <span class="o">|</span> <span class="n">deref</span><span class="p">()</span>                       <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.diskScan"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.diskScan">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">diskScan</span><span class="p">(</span><span class="n">folder</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">accurate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>                  <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scans for files and folders in the specified folder for potential</span>
<span class="sd">distributed files and folders. A distributed file is a file that exists on more</span>
<span class="sd">than 1 node. A distributed folder is a folder that that exists on more than 1</span>
<span class="sd">node and does not have any shared children. Example::</span>

<span class="sd">    applyCl.diskScan(&quot;~/ssd2&quot;)</span>
<span class="sd">    applyCl.diskScan(&quot;~/ssd2&quot;, True)</span>

<span class="sd">The first line does not return anything, but will print out something like this:</span>

<span class="sd">.. include:: ../literals/diskScan.rst</span>

<span class="sd">While the second line will return a parseable data structure instead::</span>

<span class="sd">    [[[&#39;/home/kelvin/ssd2/data/genome/RegulationFeatureActivity&#39;, [4113489746, 7912834090, 4164314316]],</span>
<span class="sd">      [&#39;/home/kelvin/ssd2/data/genome/go/release_geneontology_org&#39;, [2071645117, 4172737915, 2107005131]],</span>
<span class="sd">      [&#39;/home/kelvin/ssd2/data/genome/RegulationFeatureActivity.backup&#39;, [568878496, 552888466, 600610083]],</span>
<span class="sd">      [&#39;/home/kelvin/ssd2/data/genome/00-common_all.idx&#39;, [341738564, 671136833, 0]],</span>
<span class="sd">      [&#39;/home/kelvin/ssd2/data/genome/genbank/ch1.dat.gz&#39;, [25356744, 0, 25356764]],</span>
<span class="sd">      [&#39;/home/kelvin/ssd2/test&#39;, [136152, 273530, 136351]],</span>
<span class="sd">      [&#39;/home/kelvin/ssd2/data/genome/genbank/ch1&#39;, [0, 0, 0]]],</span>
<span class="sd">     [[&#39;/home/kelvin/ssd2/data/genome/dummy.txt&#39;, [1101, 1101, 1101]]],</span>
<span class="sd">     [[&#39;/home/kelvin/ssd2/data/genome/00-All.vcf&#39;, [32737509360, 65475018903, 32737509588]],</span>
<span class="sd">      [&#39;/home/kelvin/ssd2/data/genome/MotifFeatures/homo_sapiens.GRCh38.motif_features.gff&#39;, [13963854962, 27927709895, 13963854962]],</span>
<span class="sd">      [&#39;/home/kelvin/ssd2/data/genome/00-common_all.vcf&#39;, [2353901811, 4707803470, 2353901831]]]]</span>

<span class="sd">Remember that since an operating system usually have lots of shared files</span>
<span class="sd">(like &quot;~/.bashrc&quot;, for example), these might be mistaken as a distributed file.</span>
<span class="sd">Make sure to only scan folders that you store data in, or else it&#39;ll take a long time to return.</span>

<span class="sd">:param folder: the folder to scan through</span>
<span class="sd">:param raw: whether to return raw data or display it out nicely</span>
<span class="sd">:param accurate: if True, returns size when you read all files into RAM. If False</span>
<span class="sd">    returns size occupied by the entire file/folder (will be larger because files</span>
<span class="sd">    are arranged into different blocks in the underlying disk)</span>
<span class="sd">:param f: optional post process function applied after getting the raw results, if ``raw=False``&quot;&quot;&quot;</span> <span class="c1"># applyCl</span>
        <span class="kn">from</span> <span class="nn">k1lib.cli._applyCl</span> <span class="kn">import</span> <span class="n">diskScan4</span><span class="p">,</span> <span class="n">diskScan5</span>                      <span class="c1"># applyCl</span>
        <span class="k">if</span> <span class="n">raw</span><span class="p">:</span> <span class="k">return</span> <span class="n">diskScan4</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">accurate</span><span class="o">=</span><span class="n">accurate</span><span class="p">)</span>                      <span class="c1"># applyCl</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">diskScan5</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">accurate</span><span class="o">=</span><span class="n">accurate</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="p">(</span><span class="n">f</span> <span class="ow">or</span> <span class="n">cli</span><span class="o">.</span><span class="n">iden</span><span class="p">()))</span>   <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.balancedNodeIds"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.balancedNodeIds">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">balancedNodeIds</span><span class="p">():</span>                                                       <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a stream of node ids that&#39;s balanced based on cpu count/performance.</span>
<span class="sd">Example::</span>

<span class="sd">    # returns list of 10 node ids: [&quot;abc...&quot;, &quot;def...&quot;, &quot;abc...&quot;, ...]</span>
<span class="sd">    applyCl.balancedNodeIds() | head() | deref()</span>
<span class="sd">&quot;&quot;&quot;</span>                                                                              <span class="c1"># applyCl</span>
        <span class="kn">from</span> <span class="nn">k1lib.cli._applyCl</span> <span class="kn">import</span> <span class="n">balancedNodeIds</span>                           <span class="c1"># applyCl</span>
        <span class="k">return</span> <span class="n">balancedNodeIds</span><span class="p">()</span>                                                 <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.balancedCpus"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.balancedCpus">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">balancedCpus</span><span class="p">():</span>                                                          <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns Dict[nodeId (str) -&gt; #cpu (int))]. Could be useful to know</span>
<span class="sd">how much to split up files and folders according to your custom rules. Example::</span>

<span class="sd">    # returns {&quot;abc...&quot;: 8, &quot;def...&quot;: 19, &quot;ghi...&quot;: 88} for 7700 (4c8t), 10700k (8c16t) and 13900k (24c32t)</span>
<span class="sd">    applyCl.balancedCpus()</span>
<span class="sd">&quot;&quot;&quot;</span>                                                                              <span class="c1"># applyCl</span>
        <span class="kn">from</span> <span class="nn">k1lib.cli._applyCl</span> <span class="kn">import</span> <span class="n">loadTestGuard</span>                             <span class="c1"># applyCl</span>
        <span class="k">return</span> <span class="n">loadTestGuard</span><span class="p">()</span>                                                   <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.loadTest"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.loadTest">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">loadTest</span><span class="p">():</span>                                                              <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs a load test on the cluster.</span>
<span class="sd">Example::</span>

<span class="sd">    applyCl.loadTest()</span>

<span class="sd">What is a load test? It basically tries to perform some intensive and</span>
<span class="sd">long-running calculations on all processes on all nodes in the cluster</span>
<span class="sd">to know how good are each individual nodes. This is useful information</span>
<span class="sd">because whenever you try to split a file up to form a distributed file,</span>
<span class="sd">or move files in a folder around to form a distributed folder, the amount</span>
<span class="sd">of data each node gets is going to be proportional to this performance</span>
<span class="sd">information. More powerful nodes will have more data to process, so that</span>
<span class="sd">the total running time across all nodes is going to roughly be the same.</span>

<span class="sd">But isn&#39;t cpu count good enough for this? No, not actually. The i7 7700</span>
<span class="sd">has 4 cores, 8 threads, and the i9 13900k has 8 performance cores and 16</span>
<span class="sd">efficiency cores, totalling to 32 threads. You would suspect that the</span>
<span class="sd">13900k to be 4x (32/8=4) or 6x (24/4=6) more powerful than the 7700, but</span>
<span class="sd">it&#39;s actually 10x more powerful.</span>

<span class="sd">The test itself takes around 1-2 minutes, and the test results are going</span>
<span class="sd">to be saved locally in the folder &quot;~/.k1lib/&quot;, so that it can use that</span>
<span class="sd">info directly in future runs.&quot;&quot;&quot;</span>                                                 <span class="c1"># applyCl</span>
        <span class="kn">from</span> <span class="nn">k1lib.cli._applyCl</span> <span class="kn">import</span> <span class="n">loadTest</span>                                  <span class="c1"># applyCl</span>
        <span class="k">return</span> <span class="n">loadTest</span><span class="p">()</span>                                                        <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.getFolderSize"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.getFolderSize">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">getFolderSize</span><span class="p">(</span><span class="n">folder</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>                                   <span class="c1"># applyCl</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shortcut function to get size of a folder on the current node.&quot;&quot;&quot;</span>     <span class="c1"># applyCl</span>
        <span class="kn">from</span> <span class="nn">k1lib.cli._applyCl</span> <span class="kn">import</span> <span class="n">getFolderSize</span>                             <span class="c1"># applyCl</span>
        <span class="k">if</span> <span class="n">folder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">getFolderSize</span>                                  <span class="c1"># applyCl</span>
        <span class="k">return</span> <span class="n">folder</span> <span class="o">|</span> <span class="n">getFolderSize</span>                                            <span class="c1"># applyCl</span></div>
<div class="viewcode-block" id="applyCl.getFilesInFolder"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyCl.getFilesInFolder">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># applyCl</span>
    <span class="k">def</span> <span class="nf">getFilesInFolder</span><span class="p">(</span><span class="n">folder</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>                                       <span class="c1"># applyCl</span>
        <span class="kn">from</span> <span class="nn">k1lib.cli._applyCl</span> <span class="kn">import</span> <span class="n">getFilesInFolder</span>                          <span class="c1"># applyCl</span>
        <span class="k">if</span> <span class="n">folder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">getFilesInFolder</span>                               <span class="c1"># applyCl</span>
        <span class="k">return</span> <span class="n">folder</span> <span class="o">|</span> <span class="n">getFilesInFolder</span>                                         <span class="c1"># applyCl</span></div></div>
<span class="kn">import</span> <span class="nn">requests</span><span class="o">,</span> <span class="nn">random</span>                                                          <span class="c1"># applyCl</span>
<span class="k">if</span> <span class="n">hasRay</span><span class="p">:</span>                                                                       <span class="c1"># applyCl</span>
    <span class="nd">@ray</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">num_cpus</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>                                                      <span class="c1"># applyCl</span>
    <span class="k">class</span> <span class="nc">Storage</span><span class="p">:</span> <span class="c1"># a wrapper for specific objects, kinda like ObjectRef, but it&#39;s an ObjectRef in my control. Should not be serialized to every other place # applyCl</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>                                              <span class="c1"># applyCl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodeId</span> <span class="o">=</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">nodeId</span><span class="p">();</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="p">{};</span> <span class="bp">self</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># applyCl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoInc</span> <span class="o">=</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">AutoIncrement</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;_d&quot;</span><span class="p">)</span>                      <span class="c1"># applyCl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nodeId</span><span class="si">}</span><span class="s2">_&quot;</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span> <span class="c1"># applyCl</span>
            <span class="c1"># self.idx2 = f&quot;{random.randint(0, 900)}&quot;                            # applyCl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>                                                      <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">getIdx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span>                                        <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">getMeta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodeId</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span>                        <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>                            <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span> <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>                               <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>                               <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">incref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="c1">#; return self             # applyCl</span>
        <span class="k">def</span> <span class="nf">decref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>                                               <span class="c1"># applyCl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>                                 <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>                             <span class="c1"># applyCl</span>
            <span class="c1"># requests.get(f&quot;https://logs.mlexps.com/removed/{idx}/{v}/{self.idx2}&quot;) # applyCl</span>
            <span class="c1"># return self                                                        # applyCl</span>
        <span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span><span class="s2">&quot;1/or1/h1&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span><span class="s2">&quot;Storage&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;idx:str&quot;</span><span class="p">:</span> <span class="c1"># injecting s into v if v is a Handle # applyCl</span>
            <span class="c1"># requests.get(f&quot;https://logs.mlexps.com/deposit/{v}/{self.idx}&quot;)    # applyCl</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Handle</span><span class="p">):</span> <span class="n">v</span><span class="o">.</span><span class="n">setStorage</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>               <span class="c1"># applyCl</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">ObjectRef</span><span class="p">):</span> <span class="n">v</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>                      <span class="c1"># applyCl</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoInc</span><span class="p">();</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">incref</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>             <span class="c1"># applyCl</span>
            <span class="c1"># requests.get(f&quot;https://logs.mlexps.com/deposit/{idx}/{v}/{self.idx2}&quot;) # applyCl</span>
            <span class="k">return</span> <span class="n">idx</span>                                                           <span class="c1"># applyCl</span>
        <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">idxCtxHandle</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;idx:str&quot;</span><span class="p">:</span>       <span class="c1"># applyCl</span>
            <span class="c1"># requests.get(f&quot;https://logs.mlexps.com/execute/{idx}/{self.d.get(idx, None)}/{self.idx2}&quot;) # applyCl</span>
            <span class="c1"># if idxCtxHandle: f.__globals__[&quot;ctxHandle&quot;] = self.d[idxCtxHandle] # injecting in global variable # applyCl</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">idxCtxHandle</span><span class="p">))</span> <span class="c1"># executing &quot;pure&quot; f with some argument taken from the storage # applyCl</span>
        <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Can&#39;t be serialized!&quot;</span><span class="p">)</span>          <span class="c1"># applyCl</span>
<span class="k">else</span><span class="p">:</span>                                                                            <span class="c1"># applyCl</span>
    <span class="k">class</span> <span class="nc">Storage</span><span class="p">:</span> <span class="k">pass</span>                                                          <span class="c1"># applyCl</span>
<span class="n">_storages</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># nodeId -&gt; {idx: int, ss: [Storage]}, idx for current index to yield the storage # applyCl</span>
<span class="n">_cpuCounts</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># nodeId -&gt; int                                                  # applyCl</span>
<span class="n">_nodeIdsGen</span> <span class="o">=</span> <span class="kc">None</span>                                                               <span class="c1"># applyCl</span>
<span class="k">def</span> <span class="nf">getStorage</span><span class="p">(</span><span class="n">nodeId</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_gpus</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Storage</span><span class="p">:</span>                          <span class="c1"># getStorage</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Handles creating storage contexts. This is created mainly because it&#39;s</span>
<span class="sd">costly to actually instantiate a new actor (1-2 second/actor!), so this will</span>
<span class="sd">spawn new storage contexts till the cpu count of each node is reached. From</span>
<span class="sd">then on, it will keep reusing old storage contexts&quot;&quot;&quot;</span>                            <span class="c1"># getStorage</span>
    <span class="k">global</span> <span class="n">_nodeIdsGen</span><span class="p">;</span> <span class="n">_nodeIdsGen</span> <span class="o">=</span> <span class="n">_nodeIdsGen</span> <span class="ow">or</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">balancedNodeIds</span><span class="p">()</span>   <span class="c1"># getStorage</span>
    <span class="n">nodeId</span> <span class="o">=</span> <span class="n">nodeId</span> <span class="ow">or</span> <span class="nb">next</span><span class="p">(</span><span class="n">_nodeIdsGen</span><span class="p">)</span>                                         <span class="c1"># getStorage</span>
    <span class="k">if</span> <span class="n">num_gpus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>                                                            <span class="c1"># getStorage</span>
        <span class="k">if</span> <span class="n">nodeId</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_storages</span> <span class="ow">or</span> <span class="n">nodeId</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_cpuCounts</span><span class="p">:</span>                  <span class="c1"># getStorage</span>
            <span class="n">_storages</span><span class="p">[</span><span class="n">nodeId</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;idx&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;ss&quot;</span><span class="p">:</span> <span class="p">[]}</span>                             <span class="c1"># getStorage</span>
            <span class="n">_cpuCounts</span><span class="p">[</span><span class="n">nodeId</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodeId</span> <span class="o">|</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">aS</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>     <span class="c1"># getStorage</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_storages</span><span class="p">[</span><span class="n">nodeId</span><span class="p">][</span><span class="s2">&quot;ss&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">_cpuCounts</span><span class="p">[</span><span class="n">nodeId</span><span class="p">]:</span> <span class="c1"># add new storage context # getStorage</span>
            <span class="n">_storages</span><span class="p">[</span><span class="n">nodeId</span><span class="p">][</span><span class="s2">&quot;ss&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">specificNode</span><span class="p">(</span><span class="n">Storage</span><span class="p">,</span> <span class="n">nodeId</span><span class="p">)</span><span class="o">.</span><span class="n">remote</span><span class="p">())</span> <span class="c1"># getStorage</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">_storages</span><span class="p">[</span><span class="n">nodeId</span><span class="p">][</span><span class="s2">&quot;idx&quot;</span><span class="p">];</span> <span class="n">res</span> <span class="o">=</span> <span class="n">_storages</span><span class="p">[</span><span class="n">nodeId</span><span class="p">][</span><span class="s2">&quot;ss&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>       <span class="c1"># getStorage</span>
        <span class="n">_storages</span><span class="p">[</span><span class="n">nodeId</span><span class="p">][</span><span class="s2">&quot;idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">_cpuCounts</span><span class="p">[</span><span class="n">nodeId</span><span class="p">];</span> <span class="k">return</span> <span class="n">res</span>        <span class="c1"># getStorage</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">specificNode</span><span class="p">(</span><span class="n">Storage</span><span class="p">,</span> <span class="n">nodeId</span><span class="p">,</span> <span class="n">num_gpus</span><span class="p">)</span><span class="o">.</span><span class="n">remote</span><span class="p">()</span>                <span class="c1"># getStorage</span>
<span class="k">def</span> <span class="nf">extractStorage</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">storage</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Handle</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>       <span class="c1"># extractStorage</span>
<span class="k">class</span> <span class="nc">Handle</span><span class="p">:</span> <span class="c1"># specific object in storage, pretty much ObjectRef that I&#39;m in control of. Can be serialized to every other place # Handle</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">storage</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_or</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>                         <span class="c1"># Handle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">storage</span> <span class="o">=</span> <span class="n">storage</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_or</span> <span class="o">=</span> <span class="n">_or</span>                   <span class="c1"># Handle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodeId</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">storageId</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">storage</span><span class="o">.</span><span class="n">getMeta</span><span class="o">.</span><span class="n">remote</span><span class="p">());</span> <span class="bp">self</span><span class="o">.</span><span class="n">weakref</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># whether this Handle should decrement reference count of storage element or not # Handle</span>
    <span class="nd">@staticmethod</span>                                                                <span class="c1"># Handle</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">nodeId</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_gpus</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Handle&quot;</span><span class="p">:</span> <span class="c1"># creates new storage and put value into it # Handle</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">getStorage</span><span class="p">(</span><span class="n">nodeId</span><span class="p">,</span> <span class="n">num_gpus</span><span class="p">);</span> <span class="k">return</span> <span class="n">Handle</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">deposit</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">extractStorage</span><span class="p">(</span><span class="n">v</span><span class="p">))))</span> <span class="c1"># Handle</span>
    <span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Handle&quot;</span><span class="p">:</span> <span class="c1"># put new value into this handle&#39;s Storage # Handle</span>
        <span class="k">return</span> <span class="n">Handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">deposit</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">extractStorage</span><span class="p">(</span><span class="n">v</span><span class="p">))))</span> <span class="c1"># Handle</span>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span><span class="s2">&quot;Storage&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Handle&quot;</span><span class="p">:</span> <span class="c1"># f is a normal function. Blocks until finished executing # Handle</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>                                                               <span class="c1"># Handle</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;num_gpus&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>                                         <span class="c1"># Handle</span>
            <span class="nd">@ray</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>                                                <span class="c1"># Handle</span>
            <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">sto</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span> <span class="k">return</span> <span class="n">sto</span><span class="o">.</span><span class="n">execute</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>            <span class="c1"># Handle</span>
            <span class="k">return</span> <span class="n">Handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">inner</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="n">s</span><span class="p">))))</span> <span class="c1"># Handle</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">Handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">execute</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">)))</span> <span class="c1"># Handle</span>
    <span class="k">def</span> <span class="nf">block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Handle&quot;</span><span class="p">:</span> <span class="c1"># block execution and finalize Handle&#39;s state   # Handle</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_or</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_or</span><span class="p">)</span>                                <span class="c1"># Handle</span>
        <span class="k">return</span> <span class="bp">self</span>                                                              <span class="c1"># Handle</span>
    <span class="k">def</span> <span class="nf">executeAsync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idxCtxHandle</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Handle&quot;</span><span class="p">:</span> <span class="c1"># f is a normal function. Returns immediately, finalize it by calling .block() # Handle</span>
        <span class="c1"># requests.get(f&quot;https://logs.mlexps.com/async12/{self.idx}/N/{self.idx2}&quot;) # Handle</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span> <span class="c1"># idxCtxHandle is the (optional) string of the background handle object (left arg in pre=True mode), to be dynamically injected into the &quot;ctxHandle&quot; global variable # Handle</span>
            <span class="c1"># i1 = self.idx; i2 = self.idx2                                      # Handle</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;num_gpus&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>                                         <span class="c1"># Handle</span>
            <span class="nd">@ray</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>                                                <span class="c1"># Handle</span>
            <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">sto</span><span class="p">):</span>                                                      <span class="c1"># Handle</span>
                <span class="c1"># requests.get(f&quot;https://logs.mlexps.com/async56/{i1}/N/{i2}&quot;)   # Handle</span>
                <span class="k">return</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sto</span><span class="o">.</span><span class="n">execute</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">idxCtxHandle</span><span class="p">))</span>    <span class="c1"># Handle</span>
            <span class="c1"># requests.get(f&quot;https://logs.mlexps.com/async34/{self.idx}/N/{self.idx2}&quot;) # Handle</span>
            <span class="k">return</span> <span class="n">Handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="n">_or</span><span class="o">=</span><span class="n">inner</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">))</span>          <span class="c1"># Handle</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">Handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="n">_or</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">execute</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">idxCtxHandle</span><span class="p">))</span> <span class="c1"># Handle</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">lookup</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">))</span>          <span class="c1"># Handle</span>
    <span class="k">def</span> <span class="nf">setStorage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span> <span class="c1"># inject storage dependency into this handle, increment storage&#39;s refcount # Handle</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">storage</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">incref</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">weakref</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Handle</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;Handle idx=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="si">}</span><span class="s2"> storage=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">storageId</span><span class="si">}</span><span class="s2">&gt;&quot;</span> <span class="c1"># Handle</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">);</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;storage&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span> <span class="k">return</span> <span class="n">d</span> <span class="c1"># Handle</span>
    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">weakref</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># reconstructed Handles don&#39;t decrement reference count of variable, because Actors can&#39;t be serialized # Handle</span>
    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                                                           <span class="c1"># Handle</span>
        <span class="c1"># print(f&quot;storage: {self.storage}, nodeId: {self.nodeId}&quot;)               # Handle</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">weakref</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">decref</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>                <span class="c1"># Handle</span>
<span class="nd">@lru_cache</span>                                                                       <span class="c1"># Handle</span>
<span class="k">def</span> <span class="nf">storageWarmup</span><span class="p">():</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warming up distributed storage...&quot;</span><span class="p">);</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">applyCl</span><span class="o">.</span><span class="n">aS</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span> <span class="o">|</span> <span class="o">~</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">joinSt</span><span class="p">()</span> <span class="o">|</span> <span class="n">apply</span><span class="p">(</span><span class="n">getStorage</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">ignore</span><span class="p">();</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished warming up&quot;</span><span class="p">)</span> <span class="c1"># storageWarmup</span>
<span class="k">def</span> <span class="nf">storageSize</span><span class="p">():</span> <span class="k">return</span> <span class="n">_storages</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">op</span><span class="p">()[</span><span class="s2">&quot;ss&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">joinSt</span><span class="p">()</span> <span class="o">|</span> <span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">remote</span><span class="p">()))</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">joinSt</span><span class="p">()</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># storageSize</span>
<span class="n">thEmptySentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>                                                       <span class="c1"># storageSize</span>
<div class="viewcode-block" id="applyTh"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyTh">[docs]</a><span class="k">class</span> <span class="nc">applyTh</span><span class="p">(</span><span class="n">BaseCli</span><span class="p">):</span>                                                          <span class="c1"># applyTh</span>
<div class="viewcode-block" id="applyTh.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyTh.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">prefetch</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">bs</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="c1"># applyTh</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Kinda like the same as :class:`applyMp`, but executes ``f`` on multiple</span>
<span class="sd">threads, instead of on multiple processes. Advantages:</span>

<span class="sd">- Relatively low overhead for thread creation</span>
<span class="sd">- Fast, if ``f`` is io-bound</span>
<span class="sd">- Does not have to serialize and deserialize the result, meaning iterators can be</span>
<span class="sd">  exchanged</span>

<span class="sd">Disadvantages:</span>

<span class="sd">- Still has thread creation overhead, so it&#39;s still recommended to specify ``bs``</span>
<span class="sd">- Is slow if ``f`` has to obtain the GIL to be able to do anything</span>

<span class="sd">All examples from :class:`applyMp` should work perfectly here.&quot;&quot;&quot;</span>                <span class="c1"># applyTh</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">];</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="bp">self</span><span class="o">.</span><span class="n">bs</span> <span class="o">=</span> <span class="n">bs</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span> <span class="c1"># applyTh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefetch</span> <span class="o">=</span> <span class="n">prefetch</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>             <span class="c1"># applyTh</span></div>
<div class="viewcode-block" id="applyTh.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyTh.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">):</span>                                                       <span class="c1"># applyTh</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>                                                          <span class="c1"># applyTh</span>
            <span class="k">yield from</span> <span class="p">(</span><span class="n">it</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">batched</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bs</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="o">|</span> <span class="n">applyTh</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefetch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">joinStreams</span><span class="p">());</span> <span class="k">return</span> <span class="c1"># applyTh</span>
        <span class="n">datas</span> <span class="o">=</span> <span class="n">deque</span><span class="p">();</span> <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span>                     <span class="c1"># applyTh</span>
        <span class="n">innerF</span> <span class="o">=</span> <span class="n">fastF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">);</span> <span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span>                           <span class="c1"># applyTh</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">wrapper</span><span class="p">):</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">innerF</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>             <span class="c1"># applyTh</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefetch</span><span class="p">),</span> <span class="n">it</span><span class="p">):</span>                            <span class="c1"># applyTh</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">Wrapper</span><span class="p">(</span><span class="n">thEmptySentinel</span><span class="p">)</span>                                   <span class="c1"># applyTh</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>                        <span class="c1"># applyTh</span>
            <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">();</span> <span class="n">datas</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>                                      <span class="c1"># applyTh</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>                                                          <span class="c1"># applyTh</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">datas</span><span class="o">.</span><span class="n">popleft</span><span class="p">();</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>                        <span class="c1"># applyTh</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">thEmptySentinel</span><span class="p">:</span>                                 <span class="c1"># applyTh</span>
                <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">datas</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>                            <span class="c1"># applyTh</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Thread timed out!&quot;</span><span class="p">)</span>                          <span class="c1"># applyTh</span>
            <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">k1lib</span><span class="o">.</span><span class="n">Wrapper</span><span class="p">(</span><span class="n">thEmptySentinel</span><span class="p">)</span>              <span class="c1"># applyTh</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>                        <span class="c1"># applyTh</span>
            <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">();</span> <span class="n">datas</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>                                      <span class="c1"># applyTh</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">datas</span><span class="p">)):</span> <span class="c1"># do it this way so that python can remove threads early, due to ref counting # applyTh</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">datas</span><span class="o">.</span><span class="n">popleft</span><span class="p">();</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>                        <span class="c1"># applyTh</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">thEmptySentinel</span><span class="p">:</span>                                 <span class="c1"># applyTh</span>
                <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">datas</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>                            <span class="c1"># applyTh</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Thread timed out!&quot;</span><span class="p">)</span>                          <span class="c1"># applyTh</span>
            <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>                                                  <span class="c1"># applyTh</span></div>
    <span class="k">def</span> <span class="nf">_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">applyTh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefetch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># applyTh</span>
<div class="viewcode-block" id="applyTh.__invert__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applyTh.__invert__">[docs]</a>    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                                                        <span class="c1"># applyTh</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">();</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fastF</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>                                     <span class="c1"># applyTh</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">kwargs</span>                                                          <span class="c1"># applyTh</span>
        <span class="n">res</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>                                            <span class="c1"># applyTh</span>
        <span class="n">res</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>                                                          <span class="c1"># applyTh</span>
        <span class="k">return</span> <span class="n">res</span>                                                               <span class="c1"># applyTh</span></div></div>
<div class="viewcode-block" id="applySerial"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applySerial">[docs]</a><span class="k">class</span> <span class="nc">applySerial</span><span class="p">(</span><span class="n">BaseCli</span><span class="p">):</span>                                                      <span class="c1"># applySerial</span>
<div class="viewcode-block" id="applySerial.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applySerial.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>                                      <span class="c1"># applySerial</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies a function repeatedly. First yields input iterator ``x``. Then</span>
<span class="sd">yields ``f(x)``, then ``f(f(x))``, then ``f(f(f(x)))`` and so on. Example::</span>

<span class="sd">    # returns [2, 4, 8, 16, 32]</span>
<span class="sd">    2 | applySerial(op()*2) | head(5) | deref()</span>

<span class="sd">If the result of your operation is an iterator, you might want to</span>
<span class="sd">:class:`~k1lib.cli.utils.deref` it, like this::</span>

<span class="sd">    rs = iter(range(8)) | applySerial(rows()[::2])</span>
<span class="sd">    # returns [0, 2, 4, 6]</span>
<span class="sd">    rs | rows(1) | item() | deref()</span>
<span class="sd">    # returns []. This is because all the elements are taken by the previous deref()</span>
<span class="sd">    rs | item() | deref()</span>
<span class="sd">    # returns [[2, 8], [10, -6], [4, 16], [20, -12]]</span>
<span class="sd">    [2, 8] | ~applySerial(lambda a, b: (a + b, a - b)) | head(4) | deref()</span>

<span class="sd">    rs = iter(range(8)) | applySerial(rows()[::2] | deref())</span>
<span class="sd">    # returns [0, 2, 4, 6]</span>
<span class="sd">    rs | rows(1) | item()</span>
<span class="sd">    # returns [0, 4]</span>
<span class="sd">    rs | item() # or `next(rs)`</span>
<span class="sd">    # returns [0]</span>
<span class="sd">    rs | item() # or `next(rs)`</span>

<span class="sd">:param f: function to apply repeatedly&quot;&quot;&quot;</span>                                        <span class="c1"># applySerial</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">];</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                        <span class="c1"># applySerial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unpack</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>              <span class="c1"># applySerial</span></div>
<div class="viewcode-block" id="applySerial.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applySerial.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">):</span>                                                       <span class="c1"># applySerial</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">fastF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>                                                        <span class="c1"># applySerial</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unpack</span><span class="p">:</span>                                                          <span class="c1"># applySerial</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span> <span class="k">yield</span> <span class="n">it</span><span class="p">;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>         <span class="c1"># applySerial</span>
        <span class="k">else</span><span class="p">:</span>                                                                    <span class="c1"># applySerial</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span> <span class="k">yield</span> <span class="n">it</span><span class="p">;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>          <span class="c1"># applySerial</span></div>
<div class="viewcode-block" id="applySerial.__invert__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.applySerial.__invert__">[docs]</a>    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                                                        <span class="c1"># applySerial</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">applySerial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>                     <span class="c1"># applySerial</span>
        <span class="n">ans</span><span class="o">.</span><span class="n">unpack</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span> <span class="k">return</span> <span class="n">ans</span>                                            <span class="c1"># applySerial</span></div></div>
<span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>                                        <span class="c1"># argsort</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">arrayTypes</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="c1"># this mode ignores key and reverse! # argsort</span>
    <span class="k">if</span> <span class="n">key</span><span class="p">:</span> <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">key</span><span class="p">(</span><span class="n">it</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span> <span class="c1"># argsort</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="n">it</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>     <span class="c1"># argsort</span>
<div class="viewcode-block" id="sort"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.sort">[docs]</a><span class="k">class</span> <span class="nc">sort</span><span class="p">(</span><span class="n">BaseCli</span><span class="p">):</span>                                                             <span class="c1"># sort</span>
<div class="viewcode-block" id="sort.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.sort.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unsort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1"># sort</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sorts all lines based on a specific `column`.</span>
<span class="sd">Example::</span>

<span class="sd">    # returns [[5, &#39;a&#39;], [1, &#39;b&#39;]]</span>
<span class="sd">    [[1, &quot;b&quot;], [5, &quot;a&quot;]] | ~sort(0) | deref()</span>
<span class="sd">    # returns [[2, 3]]</span>
<span class="sd">    [[1, &quot;b&quot;], [5, &quot;a&quot;], [2, 3]] | ~sort(1) | deref()</span>
<span class="sd">    # errors out, as you can&#39;t really compare str with int</span>
<span class="sd">    [[1, &quot;b&quot;], [2, 3], [5, &quot;a&quot;]] | sort(1, False) | deref()</span>
<span class="sd">    # returns [-1, 2, 3, 5, 8]</span>
<span class="sd">    [2, 5, 3, -1, 8] | sort(None) | deref()</span>

<span class="sd">.. admonition:: unsort</span>

<span class="sd">    This is how it works::</span>

<span class="sd">        a = np.array([1, 5, 9, 2, 6, 3, 7, 4, 8])</span>
<span class="sd">        # returns np.array([1, 5, 9, 2, 6, 3, 7, 4, 8])</span>
<span class="sd">        a | sort(None, unsort=True)</span>
<span class="sd">        # returns np.array([1, 2, 3, 4, 5, 6, 7, 8, 9]), normal sort</span>
<span class="sd">        a | sort(None)</span>
<span class="sd">        # returns np.array([-3.5,  0.5,  4.5, -2.5,  1.5, -1.5,  2.5, -0.5,  3.5]), sorts, do transformation, then unsort</span>
<span class="sd">        a | (sort(None, unsort=True) | aS(lambda x: x - x[-1]/2))</span>
<span class="sd">        # returns np.array([12.25,  0.25, 20.25,  6.25,  2.25,  2.25,  6.25,  0.25, 12.25])</span>
<span class="sd">        a | (sort(None, unsort=True) | aS(lambda x: (x - x[-1]/2)**2))</span>

<span class="sd">    How this works is that it will sort everything as usual, then it&#39;ll execute the captured</span>
<span class="sd">    transformation and then it will unsort everything. This is for scenarios when an operation</span>
<span class="sd">    needs to operate on sorted data, but you still want to keep the original ordering for some</span>
<span class="sd">    reason.</span>

<span class="sd">:param column: if None, sort rows based on themselves and not an element</span>
<span class="sd">:param numeric: whether to convert column to float</span>
<span class="sd">:param reverse: False for smaller to bigger, True for bigger to smaller. Use</span>
<span class="sd">    :meth:`__invert__` to quickly reverse the order instead of using this param</span>
<span class="sd">:param unsort: whether to sort and then unsort the input or not&quot;&quot;&quot;</span>               <span class="c1"># sort</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">capture</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>                                           <span class="c1"># sort</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">column</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span> <span class="o">=</span> <span class="n">reverse</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric</span> <span class="o">=</span> <span class="n">numeric</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">unsort</span> <span class="o">=</span> <span class="n">unsort</span> <span class="c1"># sort</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filterF</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">if</span> <span class="n">numeric</span> <span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>   <span class="c1"># sort</span></div>
    <span class="k">def</span> <span class="nf">_all_array_opt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>                                         <span class="c1"># sort</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unsort</span><span class="p">:</span> <span class="k">return</span> <span class="bp">NotImplemented</span> <span class="c1"># too complex to think about right now # sort</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">;</span> <span class="n">reverse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">level</span><span class="p">;</span> <span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">));</span> <span class="n">ser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">capturedSerial</span> <span class="c1"># sort</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">-</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected sort(None) to take in 1-d array, but the array has shape </span><span class="si">{</span><span class="n">it</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">level</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># sort</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">-</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected sort(None) to take in 2-d array, but the array has shape </span><span class="si">{</span><span class="n">it</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">level</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># sort</span>
        <span class="n">bm</span> <span class="o">=</span> <span class="n">np</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">torch</span> <span class="k">if</span> <span class="p">(</span><span class="n">hasTorch</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="c1"># sort</span>
        <span class="k">if</span> <span class="n">bm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>                                                       <span class="c1"># sort</span>
            <span class="k">try</span><span class="p">:</span>                                                                 <span class="c1"># sort</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">b</span> <span class="o">=</span> <span class="n">bm</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>   <span class="n">b</span> <span class="o">=</span> <span class="n">bm</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">level</span><span class="p">,))</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">b</span><span class="p">;</span> <span class="k">return</span> <span class="n">bm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="n">ser</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="c1"># sort</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">b</span> <span class="o">=</span> <span class="n">bm</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">it</span><span class="p">[(</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="n">c</span><span class="p">)]);</span> <span class="n">b</span> <span class="o">=</span> <span class="n">bm</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">level</span><span class="p">,))</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">b</span><span class="p">;</span> <span class="k">return</span> <span class="n">bm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">b</span><span class="p">[(</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="o">|</span> <span class="n">ser</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="c1"># sort</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>                                      <span class="c1"># sort</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>                                                    <span class="c1"># sort</span>
<div class="viewcode-block" id="sort.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.sort.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">:</span><span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>                                         <span class="c1"># sort</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">;</span> <span class="n">reverse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">;</span> <span class="n">bm</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span> <span class="n">ser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">capturedSerial</span> <span class="c1"># sort</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">arrayTypes</span><span class="p">):</span>                                  <span class="c1"># sort</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected sort(None) to take in a 1-d array, but the array has shape </span><span class="si">{</span><span class="n">it</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># sort</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected sort(col) to take in a 2-d array, but the array has shape </span><span class="si">{</span><span class="n">it</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># sort</span>
            <span class="n">bm</span> <span class="o">=</span> <span class="n">np</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">torch</span> <span class="k">if</span> <span class="p">(</span><span class="n">hasTorch</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="c1"># sort</span>
            <span class="k">if</span> <span class="n">bm</span><span class="p">:</span>                                                               <span class="c1"># sort</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">bm</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">bm</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">it</span><span class="p">[:,</span><span class="n">c</span><span class="p">]);</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">bm</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">arg</span> <span class="c1"># sort</span>
                <span class="k">return</span> <span class="n">it</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">|</span> <span class="n">ser</span> <span class="o">|</span> <span class="p">(</span><span class="n">cli</span><span class="o">.</span><span class="n">rows</span><span class="p">(</span><span class="o">*</span><span class="n">argsort</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unsort</span> <span class="k">else</span> <span class="n">cli</span><span class="o">.</span><span class="n">iden</span><span class="p">())</span> <span class="c1"># sort</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filterF</span>                                                         <span class="c1"># sort</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">list</span><span class="p">((</span><span class="n">it</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">isNumeric</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric</span> <span class="k">else</span> <span class="n">it</span><span class="p">)</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span> <span class="c1"># sort</span>
        <span class="k">def</span> <span class="nf">sortF</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>                                                          <span class="c1"># sort</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c</span><span class="p">:</span> <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>                                    <span class="c1"># sort</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>                                                  <span class="c1"># sort</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unsort</span><span class="p">:</span>                                                          <span class="c1"># sort</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">f</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sortF</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">)</span>         <span class="c1"># sort</span>
            <span class="k">return</span> <span class="n">rows</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">rows</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="o">|</span> <span class="n">ser</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">rows</span><span class="p">(</span><span class="o">*</span><span class="n">argsort</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>         <span class="c1"># sort</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">f</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sortF</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">)</span> <span class="o">|</span> <span class="n">ser</span> <span class="c1"># sort</span></div>
<div class="viewcode-block" id="sort.__invert__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.sort.__invert__">[docs]</a>    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                                                        <span class="c1"># sort</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a clone that has the opposite sort order&quot;&quot;&quot;</span>                   <span class="c1"># sort</span>
        <span class="k">return</span> <span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric</span><span class="p">,</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unsort</span><span class="p">)</span>    <span class="c1"># sort</span></div></div>
<div class="viewcode-block" id="sortF"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.sortF">[docs]</a><span class="k">class</span> <span class="nc">sortF</span><span class="p">(</span><span class="n">BaseCli</span><span class="p">):</span>                                                            <span class="c1"># sortF</span>
<div class="viewcode-block" id="sortF.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.sortF.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span> <span class="n">column</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1"># sortF</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sorts rows using a function.</span>
<span class="sd">Example::</span>

<span class="sd">    # returns [&#39;a&#39;, &#39;aa&#39;, &#39;aaa&#39;, &#39;aaaa&#39;, &#39;aaaaa&#39;]</span>
<span class="sd">    [&quot;a&quot;, &quot;aaa&quot;, &quot;aaaaa&quot;, &quot;aa&quot;, &quot;aaaa&quot;] | sortF(lambda r: len(r)) | deref()</span>
<span class="sd">    # returns [&#39;aaaaa&#39;, &#39;aaaa&#39;, &#39;aaa&#39;, &#39;aa&#39;, &#39;a&#39;]</span>
<span class="sd">    [&quot;a&quot;, &quot;aaa&quot;, &quot;aaaaa&quot;, &quot;aa&quot;, &quot;aaaa&quot;] | ~sortF(lambda r: len(r)) | deref()&quot;&quot;&quot;</span>  <span class="c1"># sortF</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">];</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                        <span class="c1"># sortF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">column</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span> <span class="o">=</span> <span class="n">reverse</span>                             <span class="c1"># sortF</span></div>
<div class="viewcode-block" id="sortF.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.sortF.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">:</span><span class="n">Iterator</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>                        <span class="c1"># sortF</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">;</span> <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>                                              <span class="c1"># sortF</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">)</span>       <span class="c1"># sortF</span>
        <span class="k">def</span> <span class="nf">sortF</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>                                                          <span class="c1"># sortF</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c</span><span class="p">:</span> <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>                                    <span class="c1"># sortF</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>                                                  <span class="c1"># sortF</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">sortF</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">)</span>                 <span class="c1"># sortF</span></div>
<div class="viewcode-block" id="sortF.__invert__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.sortF.__invert__">[docs]</a>    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;sortF&quot;</span><span class="p">:</span>                                             <span class="c1"># sortF</span>
        <span class="k">return</span> <span class="n">sortF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">)</span>                      <span class="c1"># sortF</span></div></div>
<div class="viewcode-block" id="consume"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.consume">[docs]</a><span class="k">class</span> <span class="nc">consume</span><span class="p">(</span><span class="n">BaseCli</span><span class="p">):</span>                                                          <span class="c1"># consume</span>
<div class="viewcode-block" id="consume.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.consume.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="n">BaseCli</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]):</span>                 <span class="c1"># consume</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Consumes the iterator in a side stream. Returns the iterator.</span>
<span class="sd">Kinda like the bash command ``tee``. Example::</span>

<span class="sd">    # prints &quot;0\n1\n2&quot; and returns [0, 1, 2]</span>
<span class="sd">    range(3) | consume(headOut()) | toList()</span>
<span class="sd">    # prints &quot;range(0, 3)&quot; and returns [0, 1, 2]</span>
<span class="sd">    range(3) | consume(lambda it: print(it)) | toList()</span>

<span class="sd">This is useful whenever you want to mutate something, but don&#39;t want to</span>
<span class="sd">include the function result into the main stream.</span>

<span class="sd">See also: :class:`~k1lib.cli.output.tee`&quot;&quot;&quot;</span>                                      <span class="c1"># consume</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">];</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                        <span class="c1"># consume</span></div>
<div class="viewcode-block" id="consume.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.consume.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">):</span>                                                       <span class="c1"># consume</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> <span class="k">return</span> <span class="n">it</span>                                                    <span class="c1"># consume</span></div></div>
<div class="viewcode-block" id="randomize"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.randomize">[docs]</a><span class="k">class</span> <span class="nc">randomize</span><span class="p">(</span><span class="n">BaseCli</span><span class="p">):</span>                                                        <span class="c1"># randomize</span>
<div class="viewcode-block" id="randomize.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.randomize.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>                                       <span class="c1"># randomize</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Randomize input stream. In order to be efficient, this does not</span>
<span class="sd">convert the input iterator to a giant list and yield random values from that.</span>
<span class="sd">Instead, this fetches ``bs`` items at a time, randomizes them, returns and</span>
<span class="sd">fetch another ``bs`` items. If you want to do the giant list, then just pass</span>
<span class="sd">in ``float(&quot;inf&quot;)``, or ``None``. Example::</span>

<span class="sd">    # returns [0, 1, 2, 3, 4], effectively no randomize at all</span>
<span class="sd">    range(5) | randomize(1) | deref()</span>
<span class="sd">    # returns something like this: [1, 0, 2, 3, 5, 4, 6, 8, 7, 9]. You can clearly see the batches</span>
<span class="sd">    range(10) | randomize(3) | deref()</span>
<span class="sd">    # returns something like this: [7, 0, 5, 2, 4, 9, 6, 3, 1, 8]</span>
<span class="sd">    range(10) | randomize(float(&quot;inf&quot;)) | deref()</span>
<span class="sd">    # same as above</span>
<span class="sd">    range(10) | randomize(None) | deref()</span>
<span class="sd">    # returns True, as the seed is the same</span>
<span class="sd">    range(10) | randomize(seed=4) | deref() == range(10) | randomize(seed=4) | deref()</span>

<span class="sd">Note that if ``seed=True``, then it will randomize all input</span>
<span class="sd">iterators the same way and independently of each other. Meaning::</span>

<span class="sd">    r = randomize(seed=42)</span>
<span class="sd">    range(10) | r | deref() #      returns [6, 9, 1, 2, 0, 8, 3, 5, 4, 7]</span>
<span class="sd">    range(10) | r | deref() # also returns [6, 9, 1, 2, 0, 8, 3, 5, 4, 7]</span>

<span class="sd">This may or may not be desireable, but I think it&#39;s desirable.</span>

<span class="sd">:param bs: batch size</span>
<span class="sd">:param seed: if specified, will always randomize the input iterator in the same way&quot;&quot;&quot;</span> <span class="c1"># randomize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bs</span> <span class="o">=</span> <span class="n">bs</span> <span class="k">if</span> <span class="n">bs</span> <span class="o">!=</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>           <span class="c1"># randomize</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">hasTorch</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Seeded randomize() depends on PyTorch. Please install it first&quot;</span><span class="p">)</span> <span class="c1"># randomize</span></div>
    <span class="k">def</span> <span class="nf">_newGenn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                                                          <span class="c1"># randomize</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span>                       <span class="c1"># randomize</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">()</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span><span class="o">.</span><span class="n">getrandbits</span><span class="p">(</span><span class="mi">63</span><span class="p">))</span> <span class="c1"># randomize</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">generator</span><span class="o">=</span><span class="n">gen</span><span class="p">)</span>                        <span class="c1"># randomize</span>
<div class="viewcode-block" id="randomize.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.randomize.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">:</span><span class="n">Iterator</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>                        <span class="c1"># randomize</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bs</span>                                                             <span class="c1"># randomize</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">arrayTypes</span><span class="p">):</span>                                  <span class="c1"># randomize</span>
            <span class="k">if</span> <span class="n">bs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bs</span><span class="p">:</span> <span class="k">return</span> <span class="n">it</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">it</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_newGenn</span><span class="p">()(</span><span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">))]</span> <span class="c1"># randomize</span>
        <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>                                                               <span class="c1"># randomize</span>
            <span class="n">genn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_newGenn</span><span class="p">()</span>                                               <span class="c1"># randomize</span>
            <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">it</span> <span class="o">|</span> <span class="n">cli</span><span class="o">.</span><span class="n">batched</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>                             <span class="c1"># randomize</span>
                <span class="n">batch</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">batch</span><span class="p">);</span> <span class="n">perms</span> <span class="o">=</span> <span class="n">genn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">batch</span><span class="p">))</span>                    <span class="c1"># randomize</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">perms</span><span class="p">:</span> <span class="k">yield</span> <span class="n">batch</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>                               <span class="c1"># randomize</span>
        <span class="k">return</span> <span class="n">gen</span><span class="p">()</span>                                                             <span class="c1"># randomize</span></div></div>
<span class="k">class</span> <span class="nc">StaggeredStream</span><span class="p">:</span>                                                           <span class="c1"># StaggeredStream</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">:</span><span class="n">Iterator</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">every</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>                         <span class="c1"># StaggeredStream</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Not intended to be instantiated by the end user. Use :class:`stagger`</span>
<span class="sd">instead.&quot;&quot;&quot;</span>                                                                      <span class="c1"># StaggeredStream</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">every</span> <span class="o">=</span> <span class="n">every</span>                                 <span class="c1"># StaggeredStream</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                                                          <span class="c1"># StaggeredStream</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">every</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">):</span> <span class="k">yield</span> <span class="n">v</span>                 <span class="c1"># StaggeredStream</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                                                           <span class="c1"># StaggeredStream</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Length of window (length of result if you were to deref it).&quot;&quot;&quot;</span>       <span class="c1"># StaggeredStream</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">every</span>                                                        <span class="c1"># StaggeredStream</span>
<div class="viewcode-block" id="stagger"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.stagger">[docs]</a><span class="k">class</span> <span class="nc">stagger</span><span class="p">(</span><span class="n">BaseCli</span><span class="p">):</span>                                                          <span class="c1"># stagger</span>
<div class="viewcode-block" id="stagger.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.stagger.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">every</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>                                               <span class="c1"># stagger</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Staggers input stream into multiple stream &quot;windows&quot; placed serially. Best</span>
<span class="sd">explained with an example::</span>

<span class="sd">    o = range(10) | stagger(3)</span>
<span class="sd">    o | deref() # returns [0, 1, 2], 1st &quot;window&quot;</span>
<span class="sd">    o | deref() # returns [3, 4, 5], 2nd &quot;window&quot;</span>
<span class="sd">    o | deref() # returns [6, 7, 8]</span>
<span class="sd">    o | deref() # returns [9]</span>
<span class="sd">    o | deref() # returns []</span>

<span class="sd">This might be useful when you&#39;re constructing a data loader::</span>

<span class="sd">    dataset = [range(20), range(30, 50)] | transpose()</span>
<span class="sd">    dl = dataset | batched(3) | (transpose() | toTensor()).all() | stagger(4)</span>
<span class="sd">    for epoch in range(3):</span>
<span class="sd">        for xb, yb in dl: # looping over a window</span>
<span class="sd">            print(epoch)</span>
<span class="sd">            # then something like: model(xb)</span>

<span class="sd">The above code will print 6 lines. 4 of them is &quot;0&quot; (because we stagger every 4</span>
<span class="sd">batches), and xb&#39;s shape&#39; will be (3,) (because we batched every 3 samples).</span>

<span class="sd">You should also keep in mind that this doesn&#39;t really change the property of the</span>
<span class="sd">stream itself. Essentially, treat these pairs of statement as being the same thing::</span>

<span class="sd">    o = range(11, 100)</span>

<span class="sd">    # both returns 11</span>
<span class="sd">    o | stagger(20) | item()</span>
<span class="sd">    o | item()</span>

<span class="sd">    # both returns [11, 12, ..., 20]</span>
<span class="sd">    o | head(10) | deref()</span>
<span class="sd">    o | stagger(20) | head(10) | deref()</span>

<span class="sd">Lastly, multiple iterators might be getting values from the same stream window,</span>
<span class="sd">meaning::</span>

<span class="sd">    o = range(11, 100) | stagger(10)</span>
<span class="sd">    it1 = iter(o); it2 = iter(o)</span>
<span class="sd">    next(it1) # returns 11</span>
<span class="sd">    next(it2) # returns 12</span>

<span class="sd">This may or may not be desirable. Also this should be obvious, but I want to</span>
<span class="sd">mention this in case it&#39;s not clear to you.&quot;&quot;&quot;</span>                                   <span class="c1"># stagger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">every</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">every</span><span class="p">)</span>                                                  <span class="c1"># stagger</span></div>
<div class="viewcode-block" id="stagger.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.stagger.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">:</span><span class="n">Iterator</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">StaggeredStream</span><span class="p">:</span>                      <span class="c1"># stagger</span>
        <span class="k">return</span> <span class="n">StaggeredStream</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">every</span><span class="p">)</span>                             <span class="c1"># stagger</span></div>
<div class="viewcode-block" id="stagger.tv"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.stagger.tv">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># stagger</span>
    <span class="k">def</span> <span class="nf">tv</span><span class="p">(</span><span class="n">every</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">ratio</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.8</span><span class="p">):</span>                                          <span class="c1"># stagger</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience method to quickly stagger train and valid datasets.</span>
<span class="sd">Example::</span>

<span class="sd">    # returns [[16], [4]]</span>
<span class="sd">    [range(100)]*2 | stagger.tv(20) | shape().all() | deref()&quot;&quot;&quot;</span>                 <span class="c1"># stagger</span>
        <span class="k">return</span> <span class="n">stagger</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">every</span><span class="o">*</span><span class="n">ratio</span><span class="p">))</span> <span class="o">+</span> <span class="n">stagger</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">every</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ratio</span><span class="p">)))</span>     <span class="c1"># stagger</span></div></div>
<span class="n">compareOps</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;__lt__&quot;</span><span class="p">,</span> <span class="s2">&quot;__le__&quot;</span><span class="p">,</span> <span class="s2">&quot;__eq__&quot;</span><span class="p">,</span> <span class="s2">&quot;__ne__&quot;</span><span class="p">,</span> <span class="s2">&quot;__gt__&quot;</span><span class="p">,</span> <span class="s2">&quot;__ge__&quot;</span><span class="p">}</span>        <span class="c1"># stagger</span>
<div class="viewcode-block" id="op"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.op">[docs]</a><span class="k">class</span> <span class="nc">op</span><span class="p">(</span><span class="n">k1lib</span><span class="o">.</span><span class="n">Absorber</span><span class="p">,</span> <span class="n">BaseCli</span><span class="p">):</span>                                               <span class="c1"># op</span>
<div class="viewcode-block" id="op.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.op.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                                                          <span class="c1"># op</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Absorbs operations done on it and applies it on the stream. Based</span>
<span class="sd">on :class:`~k1lib.Absorber`. Example::</span>

<span class="sd">    # returns 16</span>
<span class="sd">    4 | op()**2</span>
<span class="sd">    # returns 16, equivalent to the above</span>
<span class="sd">    4 | aS(lambda x: x**2)</span>
<span class="sd">    # returns [0, 1, 4, 9, 16]</span>
<span class="sd">    range(5) | apply(op()**2) | deref()</span>
<span class="sd">    # returns [0, 1, 4, 9, 16], equivalent to the above</span>
<span class="sd">    range(5) | apply(lambda x: x**2) | deref()</span>

<span class="sd">Main advantage is that you don&#39;t have to waste keystrokes when you just want</span>
<span class="sd">to do a simple operation. How it works underneath is a little magical, so just</span>
<span class="sd">treat it as a blackbox. A more complex example::</span>

<span class="sd">    t = torch.tensor([[1, 2, 3], [4, 5, 6.0]])</span>
<span class="sd">    # returns [torch.tensor([[4., 5., 6., 7., 8., 9.]])]</span>
<span class="sd">    [t] | (op() + 3).view(1, -1).all() | deref()</span>

<span class="sd">Basically, you can treat ``op()`` as the input tensor. Tbh, you</span>
<span class="sd">can do the same thing with this::</span>

<span class="sd">    [t] | applyS(lambda t: (t+3).view(-1, 1)).all() | deref()</span>

<span class="sd">But that&#39;s kinda long and may not be obvious. This can be surprisingly resilient, as</span>
<span class="sd">you can still combine with other cli tools as usual, for example::</span>

<span class="sd">    # returns [2, 3], demonstrating &quot;&amp;&quot; operator</span>
<span class="sd">    torch.randn(2, 3) | (op().shape &amp; iden()) | deref() | item()</span>

<span class="sd">    a = torch.tensor([[1, 2, 3], [7, 8, 9]])</span>
<span class="sd">    # returns torch.tensor([4, 5, 6]), demonstrating &quot;+&quot; operator for clis and not clis</span>
<span class="sd">    (a | op() + 3 + iden() | item() == torch.tensor([4, 5, 6])).all()</span>

<span class="sd">    # returns [[3], [3]], demonstrating .all() and &quot;|&quot; serial chaining</span>
<span class="sd">    torch.randn(2, 3) | (op().shape.all() | deref())</span>

<span class="sd">    # returns [[8, 18], [9, 19]], demonstrating you can treat `op()` as a regular function</span>
<span class="sd">    [range(10), range(10, 20)] | transpose() | filt(op() &gt; 7, 0) | deref()</span>

<span class="sd">    # returns [3, 4, 5, 6, 7, 8, 9], demonstrating bounds comparison</span>
<span class="sd">    range(100) | filt(3 &lt;= op() &lt; 10) | deref()</span>

<span class="sd">This can only deal with simple operations only. For complex operations, resort</span>
<span class="sd">to the longer version ``aS(lambda x: ...)`` instead!</span>

<span class="sd">There are also operations that are difficult to achieve, like</span>
<span class="sd">``len(op())``, as Python is expecting an integer output, so</span>
<span class="sd">``op()`` can&#39;t exactly take over. Instead, you have to use :class:`aS`,</span>
<span class="sd">or do ``op().ab_len()``. Get a list of all of these special operations</span>
<span class="sd">in the source of :class:`~k1lib.Absorber`.</span>

<span class="sd">Performance-wise, in most cases, there are no degradation, so don&#39;t worry</span>
<span class="sd">about it. Everything is pretty much on par with native lambdas::</span>

<span class="sd">    n = 10_000_000</span>
<span class="sd">    # takes 1.48s</span>
<span class="sd">    for i in range(n): i**2</span>
<span class="sd">    # takes 1.89s, 1.28x worse than for loop</span>
<span class="sd">    range(n) | apply(lambda x: x**2) | ignore()</span>
<span class="sd">    # takes 1.86s, 1.26x worse than for loop</span>
<span class="sd">    range(n) | apply(op()**2) | ignore()</span>
<span class="sd">    # takes 1.86s</span>
<span class="sd">    range(n) | (op()**2).all() | ignore()</span>

<span class="sd">More complex operations still retains the same speeds, as there&#39;s a JIT compiler embedded in::</span>

<span class="sd">    # takes 2.15s</span>
<span class="sd">    for i in range(n): (i**2-3)*0.1</span>
<span class="sd">    # takes 2.53s, 1.18x worse than for loop</span>
<span class="sd">    range(n) | apply(lambda x: (x**2-3)*0.1) | ignore()</span>
<span class="sd">    # takes 2.46s, 1.14x worse than for loop</span>
<span class="sd">    range(n) | apply((op()**2-3)*0.1) | ignore()</span>

<span class="sd">Reserved operations that are not absorbed are:</span>

<span class="sd">- all</span>
<span class="sd">- __ror__ (__or__ still works!)</span>
<span class="sd">- ab_solidify</span>
<span class="sd">- op_hint&quot;&quot;&quot;</span>                                                                     <span class="c1"># op</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">({</span><span class="s2">&quot;_hint&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>                                        <span class="c1"># op</span></div>
<div class="viewcode-block" id="op.solidify"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.op.solidify">[docs]</a>    <span class="nd">@staticmethod</span>                                                                <span class="c1"># op</span>
    <span class="k">def</span> <span class="nf">solidify</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>                                                             <span class="c1"># op</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Static equivalent of ``a.ab_solidify()``.</span>
<span class="sd">Example::</span>

<span class="sd">    f = op()**2</span>
<span class="sd">    f = op.solidify(f)</span>

<span class="sd">If ``f`` is not an ``op``, then just return it without doing anything to it&quot;&quot;&quot;</span>   <span class="c1"># op</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;op&quot;</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">ab_solidify</span><span class="p">()</span>          <span class="c1"># op</span>
        <span class="k">return</span> <span class="n">f</span>                                                                 <span class="c1"># op</span></div>
<div class="viewcode-block" id="op.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.op.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">):</span>                                                       <span class="c1"># op</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ab_operate</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>                                               <span class="c1"># op</span></div>
    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>                                                         <span class="c1"># op</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">BaseCli</span><span class="p">):</span> <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">k1lib</span><span class="o">.</span><span class="n">Absorber</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__or__</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>  <span class="c1"># op</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>                                                <span class="c1"># op</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>                                                        <span class="c1"># op</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">BaseCli</span><span class="p">):</span> <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">k1lib</span><span class="o">.</span><span class="n">Absorber</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="c1"># op</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>                                                <span class="c1"># op</span>
    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>                                                        <span class="c1"># op</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">BaseCli</span><span class="p">):</span> <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">k1lib</span><span class="o">.</span><span class="n">Absorber</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__and__</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="c1"># op</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__and__</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>                                                <span class="c1"># op</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>                                         <span class="c1"># op</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ab_solidified</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ab_operate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>          <span class="c1"># op</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>                                 <span class="c1"># op</span>
    <span class="k">def</span> <span class="nf">_typehint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>                                                    <span class="c1"># op</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hint</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tAny</span><span class="p">()</span>                  <span class="c1"># op</span>
<div class="viewcode-block" id="op.op_hint"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.op.op_hint">[docs]</a>    <span class="k">def</span> <span class="nf">op_hint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_hint</span><span class="p">):</span>                                                    <span class="c1"># op</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Specify output type hint&quot;&quot;&quot;</span>                                           <span class="c1"># op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ab_sentinel</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hint</span> <span class="o">=</span> <span class="n">_hint</span>                             <span class="c1"># op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ab_sentinel</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span> <span class="k">return</span> <span class="bp">self</span>                                   <span class="c1"># op</span></div></div>
<span class="n">cli</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>                                                                      <span class="c1"># op</span>
<div class="viewcode-block" id="integrate"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.integrate">[docs]</a><span class="k">class</span> <span class="nc">integrate</span><span class="p">(</span><span class="n">BaseCli</span><span class="p">):</span>                                                        <span class="c1"># integrate</span>
<div class="viewcode-block" id="integrate.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.integrate.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>                                                    <span class="c1"># integrate</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Integrates the input.</span>
<span class="sd">Example::</span>

<span class="sd">    # returns [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]</span>
<span class="sd">    range(10) | integrate() | deref()</span>
<span class="sd">    # returns [0, 2, 6, 12, 20, 30, 42, 56, 72, 90]</span>
<span class="sd">    range(10) | integrate(2) | deref()</span>

<span class="sd">:param dt: Optional small step&quot;&quot;&quot;</span>                                                <span class="c1"># integrate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>                                                             <span class="c1"># integrate</span></div>
<div class="viewcode-block" id="integrate.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.integrate.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">):</span>                                                       <span class="c1"># integrate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>                                                         <span class="c1"># integrate</span>
            <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>                                                                <span class="c1"># integrate</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span> <span class="n">s</span> <span class="o">+=</span> <span class="n">e</span><span class="p">;</span> <span class="k">yield</span> <span class="n">s</span>                                         <span class="c1"># integrate</span>
        <span class="k">else</span><span class="p">:</span>                                                                    <span class="c1"># integrate</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">;</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>                                                  <span class="c1"># integrate</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span> <span class="n">s</span> <span class="o">+=</span> <span class="n">e</span><span class="o">*</span><span class="n">dt</span><span class="p">;</span> <span class="k">yield</span> <span class="n">s</span>                                      <span class="c1"># integrate</span></div></div>
<div class="viewcode-block" id="roll"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.roll">[docs]</a><span class="k">class</span> <span class="nc">roll</span><span class="p">(</span><span class="n">BaseCli</span><span class="p">):</span>                                                             <span class="c1"># roll</span>
<div class="viewcode-block" id="roll.__init__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.roll.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>                                               <span class="c1"># roll</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rolls the input some amount of shift.</span>
<span class="sd">Example::</span>

<span class="sd">    # returns [7, 8, 9, 0, 1, 2, 3, 4, 5, 6]</span>
<span class="sd">    range(10) | roll(3)</span>

<span class="sd">:param shift: shift amount&quot;&quot;&quot;</span>                                                    <span class="c1"># roll</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span>                                                       <span class="c1"># roll</span></div>
<div class="viewcode-block" id="roll.__ror__"><a class="viewcode-back" href="../../../cli/index.html#k1lib.cli.modifier.roll.__ror__">[docs]</a>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">):</span>                                                       <span class="c1"># roll</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span>                                                       <span class="c1"># roll</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>                 <span class="c1"># roll</span>
        <span class="k">if</span> <span class="n">hasTorch</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span> <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span> <span class="c1"># roll</span>
        <span class="k">try</span><span class="p">:</span> <span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>                                                      <span class="c1"># roll</span>
        <span class="k">except</span><span class="p">:</span> <span class="n">it</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>                                                    <span class="c1"># roll</span>
        <span class="k">return</span> <span class="p">[</span><span class="o">*</span><span class="n">it</span><span class="p">[</span><span class="o">-</span><span class="n">shift</span><span class="p">:],</span> <span class="o">*</span><span class="n">it</span><span class="p">[:</span><span class="o">-</span><span class="n">shift</span><span class="p">]]</span>                                      <span class="c1"># roll</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Quang Ho.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>